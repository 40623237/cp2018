<!doctype html>
<html><head>
<meta http-equiv="content-type" content="text/html;charset=utf-8">
<title>2018 計算機程式教學手冊</title> <link rel="stylesheet" type="text/css" href="./../static/cmsimply.css">

<script type="text/javascript" src="./../static/syntaxhighlighter/shCore.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushJScript.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushJava.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushPython.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushSql.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushXml.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushPhp.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushLua.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCpp.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCss.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCSharp.js"></script>
<link type="text/css" rel="stylesheet" href="./../static/syntaxhighlighter/css/shCoreDefault.css"/>
<script type="text/javascript">SyntaxHighlighter.all();</script>

<!-- for LaTeX equations 暫時不用
<script src="https://scrum-3.github.io/web/math/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>
<script type="text/javascript">
init_mathjax = function() {
    if (window.MathJax) {
        // MathJax loaded
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
            },
            displayAlign: 'left', // Change this to 'center' to center equations.
            "HTML-CSS": {
                styles: {'.MathJax_Display': {"margin": 0}}
            }
        });
        MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
    }
}
init_mathjax();
</script>
-->
<!-- 暫時不用
<script src="./../static/fengari-web.js"></script>
<script type="text/javascript" src="./../static/Cango-13v08-min.js"></script>
<script type="text/javascript" src="./../static/CangoAxes-4v01-min.js"></script>
<script type="text/javascript" src="./../static/gearUtils-05.js"></script>
-->
<!-- for Brython 暫時不用
<script src="https://scrum-3.github.io/web/brython/brython.js"></script>
<script src="https://scrum-3.github.io/web/brython/brython_stdlib.js"></script>
-->

<script src="./../static/jquery.js"></script>
<script type="text/javascript">
$(function(){
    $("ul.topmenu> li:has(ul) > a").append('<div class="arrow-right"></div>');
    $("ul.topmenu > li ul li:has(ul) > a").append('<div class="arrow-right"></div>');
});
</script>

</head><header><h1>2018 計算機程式教學手冊</h1> <confmenu>
<ul>
<li><a href="index.html">Home</a></li>
<li><a href="sitemap.html">Site Map</a></li>

</ul>
</confmenu></header>
<div class='container'><nav><ul id='css3menu1' class='topmenu'><li><a href='簡介.html'>簡介</a><ul><li><a href='機械設計.html'>機械設計</a><li><a href='Pointer.html'>Pointer</a><ul><li><a href='指標教材.html'>指標教材</a></li></li></ul></ul><li><a href='工具.html'>工具</a><ul><li><a href='Git.html'>Git</a><li><a href='Fossil SCM.html'>Fossil SCM</a><li><a href='Leo Editor.html'>Leo Editor</a><li><a href='SCiTE.html'>SCiTE</a><li><a href='TinyCC.html'>TinyCC</a><li><a href='Qt.html'>Qt</a><li><a href='CMSimfly.html'>CMSimfly</a></li></ul><li><a href='應用範例.html'>應用範例</a><ul><li><a href='計算器.html'>計算器</a><li><a href='Tinkercad.html'>Tinkercad</a><li><a href='讀寫網頁內容.html'>讀寫網頁內容</a><li><a href='查英文單字.html'>查英文單字</a><li><a href='docx 轉 pdf.html'>docx 轉 pdf</a><li><a href='網際繪圖.html'>網際繪圖</a><li><a href='V-rep.html'>V-rep</a><li><a href='輔助設計套件.html'>輔助設計套件</a></li></ul><li><a href='分組專題.html'>分組專題</a><ul><li><a href='分組題目.html'>分組題目</a><li><a href='符號式推導.html'>符號式推導</a><li><a href='網際平面連桿模擬.html'>網際平面連桿模擬</a></li></ul></nav><section>Pointer << <a href='Pointer.html'>Previous</a> <a href='工具.html'>Next</a> >> 工具<br /><h1>指標教材</h1>
<p>來源:&nbsp;<a href="http://pweb.netcom.com/~tjensen/ptr/pointers.htm">http://pweb.netcom.com/~tjensen/ptr/pointers.htm</a>&nbsp;</p>
<p>前言</p>
<p>本文件旨在向 C 程式語言的初學者介紹指標. 過去幾年, 無論是在 FidoNet 與 UseNet 有關 C 的會議場合, 特別注意到有許多 C 程式語言的初學者, 似乎對於指標的基本用法, 感到有些困難. 因此特別利用較多的範例, 希望以淺顯的說明來解釋指標的用法.</p>
<p>這份文件的第一版本, 如同此一版本, 是被放在公共領域. 當時是由 Bob Stout 將資料放在 PTR-HELP.TXT 的文件檔中, 並納入 SNIPPETS 的收集中加以發行. 之後, 又在原始資料中增添了許多內容並且修正了一些錯誤.</p>
<p>致謝</p>
<p>要感謝許多不為人知的使用者, 將許多問題公佈在 FidoNet 的 C Echo 論壇中, 或是 UseNet comp.lang.c 新聞群組中, 或是在其他網路上的幾個會議區,這些要感謝的人士可能無法一一列出. 其中特別要感謝 Bob Stout 肯將這份資料的第一版本放入他所收集的 SNIPPETS 檔案中.</p>
<p>關於作者:</p>
<p>Teb Jensen 是一位退休的電子工程師, 主要專注於電磁錄音領域中的硬體設計與管理職務. 程式則是自 1968 年以來閒暇時的興趣, 當時正學著如何以打卡的方式讓程式送給電腦主機執行. (那時的主機擁有 64 K 的磁心記憶體)</p>
<p>使用本資料:</p>
<p>這份資料以公共領域授權釋出. 任何人可以採用任何形式, 複製或散佈這份資料. 唯一的要求, 則是若這份資料被用於課程教學, 希望能夠完整呈現, 亦即, 包含所有章節, 包括前言與簡介.</p>
<p>並且任課教師能夠利用下方的電子郵箱通知我一聲. 之所以如此要求, 主要是希望這份資料能夠對其他人有用, 況且我並不要求金錢回報. 只是希望能夠透過使用這份資料的用戶回饋, 多少確認一下這個目標能夠達成.</p>
<p>此外, 並非一定要是課程教學者可以寫信給我. 感謝任何覺得此份資料有用或提供建設性批評的任何人, 都能告訴我一聲, 我將會透過電子郵件回答相關問題.</p>
<p><a href="https://en.wikipedia.org/wiki/Ted_Jensen">Ted Jensen</a><span>&nbsp;</span>tjensen@netcom.com P.O. Box 324 1-415-365-8452 Redwood City, CA 94064 Dec. 1995</p>
<p>簡介</p>
<p>若您想要專精於利用 C 程式語言編寫程式碼, 就必須徹底了解如何使用指標. 然而, C 指標對初學者而言, 經常是一項障礙, 尤其對於從 Fortran, Pascal 或 Basic 程式語言轉進的學習者.</p>
<p>這份資料旨在幫助初學者了解指標. 為了能讓這份資料發揮最大功能, 使用者最好能夠實際執行文章中所列出的各個程式. 因此所有的程式碼都採 ANSI 標準, 以便讓任何符合 ANSI 標準的編譯器都能執行這些程式碼. 內文與程式碼之間, 也特別加以區分開來, 以便使用者可以直接利用複製的方式, 取的各段落的程式碼, 套用到其他系統中進行編譯. 如此才能確實了解這裡所提供的資料.</p>
<p>第一章: 何謂指標?</p>
<p>C 語言初學者必須面對的難題之一, 就是指標的用法.</p>
<p>這份教材的目的, 就是針對初學者簡介指標及其應用.</p>
<p>其實初學者會對指標產生疑惑, 大多源自於在學習 C 語言時, 對於變數的概念經常一知半解.</p>
<p>因此這裡就由 C 變數的一般用法說起.</p>
<p>程式中的變數都必須加以命名, 以便存放數值.</p>
<p>而編譯器與連結器在處理變數時, 就會挪出電腦記憶體中的特定區域, 以存放變數的值</p>
<p>這些特定區域的大小, 取決於變數允許存放值的範圍.</p>
<p>例如, 在 32 位元電腦, 一個整數變數的存放範圍, 需要為 4 位元. 而在舊的 16 位元電腦, 整數存放需要 2 位元.</p>
<p>C 程式中的整數變數存放範圍大小, 在各種機器上不一定相同.</p>
<p>並且 C 程式中的整數變數也不只一種, 在許多 C 程式教科數中,可以發現有整數, 長整數, 短整數等. 這裡則假設使用 32 位元系統, 因此整數需要 4 位元的存放空間.</p>
<p>可以採用下列程式碼,在您所使用的系統中, 查探特定整數型別所需要的記憶體空間:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">#include &lt;stdio.h&gt;
 
int main()
{
printf("size of a short is %d\n", sizeof(short));
printf("size of a int is %d\n", sizeof(int));
printf("size of a long is %d\n", sizeof(long));
}</pre>
<p><a href="http://codepad.org/iQqRmLnh">在 codepad.org 執行上述 C 程式</a></p>
<p>當我們宣告一個變數時, 亦即告知編譯器兩件事, 變數名稱與變數型別. 例如, 可以透過</p>
<p>int k;</p>
<p>宣告名稱為 k 的整數型別變數. 當編譯器看到 "int" 的敘述值, 就會在電腦的記憶體中, 保留 4 位元的空間, 以便存放整數變數 k 的值.</p>
<p>此外, 電腦也會設置一個符號表, 註明符號 k 與其在記憶體中用來存放 4 位元資料的相對位址.宣告名稱為 k 的整數型別變數. 當編譯器看到 "int" 的敘述值, 就會在電腦的記憶體中, 保留 4 位元的空間, 以便存放整數變數 k 的值.<br>因此, 若在變數宣告後, 使用</p>
<p>k = 2;2 這個數值, 就會在程式執行時, 被放在保留給 k 變數的記憶體位址中.</p>
<p>在 C 語言中, 整數 k 變數, 可視為一個物件. 其中有兩個值與物件 k 有關, 也就是存放的數值與存放的位址. 有些參考書中將者兩個數值稱為"右值"與"左值". (2 為右值, 而變數位址為左值)</p>
<p>在某些語言中, 左值只能放在指定"等號"的左邊, 而右值則只能放在右邊. 位置放錯, 例如: 2 = k, 就會出錯.</p>
<p>其實, C 語言中有關左值得定義, 根據 K&amp;R II (page 197): [1], 則有些變動.</p>
<p>"物件為儲存區域的名稱, 而左值則為指向該物件的表示式."</p>
<p>這裡先採引用的定義加以說明, 後續將會進一步針對指標加以說明.</p>
<p>接著, 假如程式碼為:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">int j, k;
k = 2; 
j = 7;    &lt;-- line 1 
k = j;    &lt;-- line 2</pre>
<p>編譯器會將第一行 (line 1) 的 j 解讀為變數 j 的位址 (也就是左值), 並且將值 7 放到該位址. 在第二行 (line 2), 則會將 j 視為右值 (因為在"指定"運算子的右方), 指的則是存放在 j 記憶體中的 7 這個數值. 因此第二行執行過後, 存放在 j 的 7 這個數值, 就會被放到 k 變數所對應的"左值" (記憶體位址) 中.</p>
<p>在這些範例中, 採用的都是將右值從一個儲存位址, 經由複製將 4 位元的資料複製到另外一個儲存位址. 假如使用 2 位元整數, 則會複製 2 位元資料.</p>
<p>這裡, 就會需要一種變數, 用來存放左值 (記憶體位址). 存放此一變數的值, 隨系統而異, 舊的桌上電腦總共只有 64K 的記憶體, 每存放一個整數位址會佔去 2 位元.</p>
<p>更多位元數的電腦 (例如 64 位元電腦), 則需要更多的位元位址來存放一個整數資料.</p>
<p>實際需要的記憶體大小並不重要, 需要的則是一種方法, 通知編譯器在哪一位址存放哪些資料.</p>
<p>這樣的變數稱為"指標變數" (隨後將說明得更清楚). 在 C 語言中定義指標變數時, 必須在變數名稱前方, 加上一個 * 符號. 而這些指標變數的型別, 隨著要存放在指標位址中的資料型別而定, 例如, 假如宣告:</p>
<p>int *ptr;</p>
<p>ptr 為變數名稱 (與之前的整數變數名稱 k 相同). 而 "*" 符號則告知編譯器, 此一宣告為指標變數, 亦即保留出足夠的記憶體存放位址. 最前方的 int 則表示, 希望此一指標變數用來存放整數. 而此一指標稱為"指向整數". 需要特別注意的是, 當使用 int k; 時並沒有給 k 初始值, 只有在任何符合 ANSI 規範的編譯器中, 會將宣告在函式外的變數通通以 0 初始.</p>
<p>同樣地, ptr 也沒有初始值, 亦即, 還沒有在上述宣告之後, 在保留的位址空間上, 放入任何值. 這裡若宣告是在任何函式之外, 就會被賦予初值, 並且保證不會指向任何 C 物件或函式. 以這種方式初始的指標, 被稱為 "空"指標 (null pointer).</p>
<p>而空指標並不一定會被放入 "0" 值, 因為這取決於特定系統中的設定. 為了在不同系統中的不同編譯器彼此相容, 就會利用巨集 (macro) 來表示空指標. 此巨集以 NULL 命名. 因此, 若以 NULL 設定指標值, 則可以確定在不同機器上, 這些指標變數一定是空指標.</p>
<p>與整數是否為 0 的判斷式 if(k ==0) 相類似, 可以利用 if(ptr == NULL) 判斷是否 ptr 為空指標.</p>
<p>但是, 回到新變數 ptr 的應用, 假設要將整數變數 k 所對應的位址, 存入 ptr, 就必須使用"位址運算子", 寫成:</p>
<p>ptr = &amp;k;</p>
<p>"位址運算子"的作用是用來取 k 的左值 (位址), 即使這時 k 位於等號右邊, 上述程式會將 k 的值複製到指標 ptr 的儲存空間中. 這時, ptr 稱為"指向" k.</p>
<p>接著再討論另外一個運算子.</p>
<p>也就是所謂的"取值運算子" (dereferencing operator), 就是一個 * 符號. 使用方法如下:</p>
<pre>*ptr = 7;</pre>
<p>這行程式會將 7 這個數值,複製到 ptr 變數所指向的位址. 也就是說, 假如 ptr 指向 k (ptr 為 k 存放資料的記憶體位址), 這行程式就會將 k 的值設為 7. 換言之, * 運算子可用來改變 ptr 所指向的值, 而不是指標本身的值. (註:指標本身為位址, 也就是所謂的左變數)</p>
<p>因此, 可以利用:</p>
<p>printf("%d\n",*ptr);</p>
<p>將目前存放在 ptr 所指向位址的整數值, 給印到螢幕.</p>
<p>要釐清上述說明, 可以執行下列程式, 並仔細探討程式碼與其輸出.</p>
<p><span>------------ Program 1.1 ---------------------------------</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">/* Program 1.1 from PTRTUT10.TXT   6/10/97 */
 
#include &lt;stdio.h&gt;
 
int j, k;
int *ptr;
 
int main(void)
{
    j = 1;
    k = 2;
    ptr = &amp;k;
    printf("\n");
    printf("j has the value %d and is stored at %p\n", j, (void *)&amp;j);
    printf("k has the value %d and is stored at %p\n", k, (void *)&amp;k);
    printf("ptr has the value %p and is stored at %p\n", ptr, (void *)&amp;ptr);
    printf("The value of the integer pointed to by ptr is %d\n", *ptr);
 
    return 0;
}</pre>
<p><a href="http://codepad.org/w8R9mp9h">在 codepad.org 執行 Program 1.1</a></p>
<p>請注意: 我們還沒有談到 C 程式中的 (void *) 表示式. 這裡可以先納入您的測試程式碼中, 隨後將會加以說明.</p>
<p>結論:</p>
<p>變數宣告必須指定名稱與型別<span class="o">.</span> <span class="o">(</span><span class="nt">例如</span><span class="o">:</span> <span class="nt">int</span> <span class="nt">k</span><span class="o">;)</span> <span class="nt">2</span><span class="o">.</span> <span class="nt">指標變數宣告也是指定名稱與型別</span><span class="o">.</span> <span class="o">(</span><span class="nt">例如</span><span class="o">:</span> <span class="nt">int</span> <span class="o">*</span><span class="nt">ptr</span><span class="o">;),</span> <span class="nt">其中的</span> <span class="o">*</span> <span class="nt">告知編譯器</span><span class="o">,</span> <span class="nt">該名稱為</span> <span class="nt">ptr</span> <span class="nt">的變數</span><span class="o">,</span> <span class="nt">為一個指標變數</span><span class="o">,</span> <span class="nt">而其型別為該指標指向的資料型別</span> <span class="o">(</span><span class="nt">這裡為整數</span><span class="o">).</span> <span class="nt">3</span><span class="o">.</span> <span class="nt">一旦變數已經宣告</span><span class="o">,</span> <span class="nt">可以透過變數前方的位址運算子</span><span class="o">,</span> <span class="nt">取得其位址</span><span class="o">,</span> <span class="nt">例如</span> <span class="o">&amp;</span><span class="nt">k</span><span class="o">.</span> <span class="nt">4</span><span class="o">.</span> <span class="nt">可以由指標中</span><span class="s2">"取值"</span><span class="o">,</span> <span class="nt">亦即</span><span class="o">,</span> <span class="nt">以</span> <span class="o">*</span> <span class="nt">指定到指標所參照的值</span><span class="o">,</span> <span class="nt">例如</span><span class="o">:</span> <span class="o">*</span><span class="nt">ptr</span><span class="o">.</span> <span class="nt">5</span><span class="o">.</span> <span class="nt">變數的左值為被用來存放在記憶體中的位址值</span><span class="o">,</span> <span class="nt">而變數的右值則式被存放在該位址的數值</span><span class="o">.<br><br></span></p>
<p>參考資料:</p>
<p>"The C Programming Language" 2nd Edition B. Kernighan and D. Ritchie Prentice Hall ISBN 0-13-110362-8</p>
<p>第二章: 指標型別與陣列</p>
<p>接著讓我們來看看, 為何需要指定指標指向變數的型別, 例如: int *ptr; 原因之一是, 宣告之後, 可以透過指向, 寫成:</p>
<p>*ptr = 2;</p>
<p>編譯器就會知道要配置多少記憶體給 ptr 變數, 假如 ptr 宣告為指向整數, 電腦就會複製 4 位元的資料, 其它的浮點與雙浮點變數也是相同. 定義指向變數型別的另外一個用途就是編譯器可以解譯程式碼. 例如, 記憶區中存放 10 個連續的整數資料時, 需要 40 位元的記憶體.</p>
<p>假如整數指標 ptr 為這些整數中的第一個變數, 若該整數位於記憶體位址 100. 當程式寫為:</p>
<p>ptr + 1;</p>
<p>因為編譯器知道 ptr 為一個指標變數 (亦即, 其值為一組位址)並且指向某一整數 (目前位址為 100, 即是該整數所在位址), 當 ptr 加上 4 而不是 1 之後, 該指標將會指向下一個整數, 也就是記憶體 104.</p>
<p>相同的概念下, 若 ptr 指向短整數, 則應該加上 2 而不是 1. 對於浮點, 雙浮點或使用者自訂的資料型別 - 結構, 也是類似.</p>
<p>儘管這並非我們常見的"加法", 但是在 C 語言中, 可以透過指標算數進行"加法"運算, 隨後將會再予以說明.</p>
<p>同理, 因為 ++ptr 與 ptr++ 與 ptr + 1 等同 (儘管 ptr 增量的時機點並不一樣).</p>
<p>讓指標以 ++ 增量運算子進行增量, 無論是先加或後加, 由 sizeof(type) 中所得到的位址增量, 其型別均為該物件指向變數的型別 (整數為 4 位元).</p>
<p>由於這 10 個整數位於記憶體中連續區塊上, 指標可以被用於整數資料陣列的處理.</p>
<p>例如:</p>
<p>int my_array[] = {1,23,17,4,-5,100};</p>
<p>陣列中帶有 6 個整數. 可以透過 my_array 的索引代表這些整數. 亦即利用 my_array[0] 到 my_array[5] 加以表示, 也可以透過指標加以表示成:</p>
<p>int *ptr;<br>ptr = &amp;my_array[0]; /* 將指標指向陣列中的第一個整數*/</p>
<p>接著就可以使用陣列索引或取值運算, 列出陣列.</p>
<p>下列程式可以用來展示此一應用:</p>
<p>----------- Program 2.1 -----------------------------------</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">/* Program 2.1 from PTRTUT10.HTM   6/13/97 */
 
#include &lt;stdio.h&gt;
 
int my_array[] = {1,23,17,4,-5,100};
int *ptr;
 
int main(void)
{
    int i;
    ptr = &amp;my_array[0];     /* point our pointer to the first
                                      element of the array */
    printf("\n\n");
    for (i = 0; i &lt; 6; i++)
    {
      printf("my_array[%d] = %d   ",i,my_array[i]);   /*&lt;-- A */
      printf("ptr + %d = %d\n",i, *(ptr + i));        /*&lt;-- B */
    }
    return 0;
}</pre>
<p><a href="http://codepad.org/3fgCKs7N">在 codepad.org 執行 Program 2.1</a></p>
<p>編譯執行上列程式就可以仔細觀察 A 行與 B 行程式分別採用兩種方法列出陣列中的同一內容.</p>
<p>也可以清楚看到 B 行程式如何應用"取值"運算, 亦即, 首先在指標增量後, 在新的指標中取值. 將 B 行程式改為</p>
<p>printf("ptr + %d = %d\n",i, *ptr++);</p>
<p>之後再執行, 接著改為:</p>
<p>printf("ptr + %d = %d\n",i, *(++ptr));</p>
<p>再執行, 執行之前先判定結果, 並與實際執行結果進行比較.</p>
<p>在 C 語言, 可以利用 var_name 來替代 &amp;var_name[0], 因此在程式碼中寫成:</p>
<div class="codehilite">
<pre>ptr = &amp;my_array[0];
<br><span>或:</span><br><br></pre>
<pre>ptr = my_array;</pre>
<p>都會得到相同的結果.</p>
<p>因此許多參考書都寫道: 陣列的變數名稱就是指標. 但是比較好的想法則是: 陣列的變數名稱就是陣列中第一元件的位址. 許多初學者 (包含作者本人), 都會將其視為指標.</p>
<p>但是, 可以寫成:</p>
<p>ptr = my_array;</p>
<p>但是卻不能寫成:</p>
<p>my_array = ptr;</p>
<p>原因就是 ptr 為變數, 但是 my_array 卻是常數, 也就是說, my_array 第一元件的位址, 一旦在 my_array[] 完成宣告後, 就不可以改變.</p>
<p>先前曾討論的左值, 中引用 K&amp;R-2 中所言:</p>
<p>"物件為儲存區域的名稱, 而左值則為指向該物件的表示式."</p>
<p>這就衍生出一個有趣的議題. 因為 my_array 為儲存區域的代表名稱, 為何 my_array 在上面的指定敘述程式中, 卻不能用在左值區域?</p>
<p>為了說明這點, 可以將 my_array 視為"不可改變的左值".</p>
<p>上列範例可以將:</p>
<pre>ptr = &amp;my_array[0];<br><br><span>改為:</span><br><br></pre>
<pre>ptr = my_array;<br><br></pre>
<p>確認兩者會得到相同的結果.</p>
<p>至於 ptr 與 my_array 之間的差異, 有人將陣列變數名稱視為"常數指標". 為了充分了解所謂"常數"的真諦, 重回變數定義時的說明.</p>
<p>當變數宣告時, 用來存值的記憶體就必須加以配置. 這時變數可以透過兩個層面來看.</p>
<p>用在指定運算左邊時, 編譯器會視其為記憶位址, 用來指向右側所設定的值.</p>
<p>若被用在運算右邊時, 變數名稱會被解讀為存在該記憶體中的值.</p>
<p>有了以上的概念, 關注簡單的常數運算:</p>
<pre>int i, k;
i = 2;<br><br></pre>
<p>其中 i 為存放 2 常數的變數, 並非直接在資料記憶區塊中指定, 而是直接存入程式記憶區塊.</p>
<p>當 k = i; 程式碼就會到 &amp;i 位址中抓取要複製到 k 的值, 而 i = 2; 只是將 2 放入程式碼, 而沒有取值的運作. 也就是說, k 與 i 都是物件, 但是 2 則非物件.</p>
<p>同理, 由於 my_array 為常數 (為位址值), 一旦編譯器設好用來存值得區域後, my_array[0] 存值得記憶體位址就已經確定, 因此可以使用:</p>
<pre>ptr = my_array;<br><br>將此在程式區段中的常數位址設給 ptr, 其中並沒有牽涉到資料區段的取值操作.</pre>
<p>這時就可進一步說明第一章程式 1.1. 中 (void *) 的應用. 由於指標可被用來指向各種資料型別. 除了可以指向整數, 也可以指向字元, 之後還會介紹指向結構與指向指標的指標變數.</p>
<p>由於在不同系統中的指標儲值大小會有差別, 並且指標的記憶體空間會隨著指向物件資料型別差異而有所不同.</p>
<p>因此若將長整數指給短整數資料型別變數時, 就會發生問題, 也可以將某一型別的指標變數指定給其他不同型別指標變數時, 產生問題.</p>
<p>為了克服此一問題, C 語言提供 void 這個空的指標資料型別.</p>
<p>假如將某一指標設定為:</p>
<p>void *vptr;</p>
<p>空指標可以視為通用指標. 由於 C 語言不允許整數型別指標與字元型別指標之間的資料交換或比較. 這時就可以透過空指標作為中介, 在特殊情況下在指標型別間進行資料轉換.</p>
<p>在第一章的 1.1 程式中, 就是使用空指標將整數指標轉成能與 %p 資料相符的格式.</p>
<p>下列各章, 也將透過此一概念進行資料轉換.</p>
<p>這裡列出許多技術資料給初學者, 首次閱讀時或許不很容易理解. 因此需要前後執行幾次程式, 看看結果, 並且仔細查驗這兩個例子中的程式碼與產出結果, 才會有所突破.</p>
<p>接下來, 將討論指標, 字元陣列與字串間的關係.</p>
</div>
<pre><span class="o"></span></pre><br />Pointer << <a href='Pointer.html'>Previous</a> <a href='工具.html'>Next</a> >> 工具</section></div></body></html>