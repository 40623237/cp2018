<!doctype html>
<html><head>
<meta http-equiv="content-type" content="text/html;charset=utf-8">
<title>2018 計算機程式教學手冊</title> <link rel="stylesheet" type="text/css" href="./../static/cmsimply.css">

<script type="text/javascript" src="./../static/syntaxhighlighter/shCore.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushJScript.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushJava.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushPython.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushSql.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushXml.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushPhp.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushLua.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCpp.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCss.js"></script>
<script type="text/javascript" src="./../static/syntaxhighlighter/shBrushCSharp.js"></script>
<link type="text/css" rel="stylesheet" href="./../static/syntaxhighlighter/css/shCoreDefault.css"/>
<script type="text/javascript">SyntaxHighlighter.all();</script>

<!-- for LaTeX equations 暫時不用
<script src="https://scrum-3.github.io/web/math/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>
<script type="text/javascript">
init_mathjax = function() {
    if (window.MathJax) {
        // MathJax loaded
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
            },
            displayAlign: 'left', // Change this to 'center' to center equations.
            "HTML-CSS": {
                styles: {'.MathJax_Display': {"margin": 0}}
            }
        });
        MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
    }
}
init_mathjax();
</script>
-->
<!-- 暫時不用
<script src="./../static/fengari-web.js"></script>
<script type="text/javascript" src="./../static/Cango-13v08-min.js"></script>
<script type="text/javascript" src="./../static/CangoAxes-4v01-min.js"></script>
<script type="text/javascript" src="./../static/gearUtils-05.js"></script>
-->
<!-- for Brython 暫時不用
<script src="https://scrum-3.github.io/web/brython/brython.js"></script>
<script src="https://scrum-3.github.io/web/brython/brython_stdlib.js"></script>
-->

<script src="./../static/jquery.js"></script>
<script type="text/javascript">
$(function(){
    $("ul.topmenu> li:has(ul) > a").append('<div class="arrow-right"></div>');
    $("ul.topmenu > li ul li:has(ul) > a").append('<div class="arrow-right"></div>');
});
</script>

</head><header><h1>2018 計算機程式教學手冊</h1> <confmenu>
<ul>
<li><a href="index.html">Home</a></li>
<li><a href="sitemap.html">Site Map</a></li>

</ul>
</confmenu></header>
<div class='container'><nav><ul id='css3menu1' class='topmenu'><li><a href='簡介.html'>簡介</a><ul><li><a href='機械設計.html'>機械設計</a><li><a href='指標教材.html'>指標教材</a></li></ul><li><a href='工具.html'>工具</a><ul><li><a href='Git.html'>Git</a><li><a href='Fossil SCM.html'>Fossil SCM</a><li><a href='Leo Editor.html'>Leo Editor</a><li><a href='SCiTE.html'>SCiTE</a><li><a href='TinyCC.html'>TinyCC</a><li><a href='Qt.html'>Qt</a><li><a href='CMSimfly.html'>CMSimfly</a></li></ul><li><a href='應用範例.html'>應用範例</a><ul><li><a href='計算器.html'>計算器</a><li><a href='Tinkercad.html'>Tinkercad</a><li><a href='讀寫網頁內容.html'>讀寫網頁內容</a><li><a href='查英文單字.html'>查英文單字</a><li><a href='docx 轉 pdf.html'>docx 轉 pdf</a><li><a href='網際繪圖.html'>網際繪圖</a><li><a href='V-rep.html'>V-rep</a><li><a href='輔助設計套件.html'>輔助設計套件</a></li></ul><li><a href='分組專題.html'>分組專題</a><ul><li><a href='分組題目.html'>分組題目</a><li><a href='符號式推導.html'>符號式推導</a><li><a href='網際平面連桿模擬.html'>網際平面連桿模擬</a></li></ul></nav><section>機械設計 << <a href='機械設計.html'>Previous</a> <a href='工具.html'>Next</a> >> 工具<br /><h1>指標教材</h1>
<p>指標:&nbsp;<a href="http://cad-lab.github.io/manual/post/c-cheng-shi-yu-yan-de-zhi-biao-yu-zhen-lie-dao-yin-zhong-wen-fan-yi.html">http://cad-lab.github.io/manual/post/c-cheng-shi-yu-yan-de-zhi-biao-yu-zhen-lie-dao-yin-zhong-wen-fan-yi.html</a>&nbsp;</p>
<p>第一章: 何謂指標?</p>
<p>C 語言初學者必須面對的難題之一, 就是指標的用法.</p>
<p>這份教材的目的, 就是針對初學者簡介指標及其應用.</p>
<p>其實初學者會對指標產生疑惑, 大多源自於在學習 C 語言時, 對於變數的概念經常一知半解.</p>
<p>因此這裡就由C 變數的一般用法說起.</p>
<p>程式中的變數都必須加以命名, 以便存放數值.</p>
<p>而編譯器與連結器在處理變數時, 就會挪出電腦記憶體中的特定區域, 以存放變數的值.</p>
<p>這些特定區域的大小, 取決於變數允許存放值的範圍.</p>
<p>例如, 在 32 位元電腦, 一個整數變數的存放範圍, 需要為 4 位元. 而在舊的 16 位元電腦, 整數存放需要 2 位元.</p>
<p>C 程式中的整數變數存放範圍大小, 在各種機器上不一定相同.</p>
<p>並且 C 程式中的整數變數也不只一種, 在許多 C 程式教科數中,可以發現有整數, 長整數, 短整數等. 這裡則假設使用 32 位元系統, 因此整數需要 4 位元的存放空間.</p>
<p>可以採用下列程式碼,在您所使用的系統中, 查探特定整數型別所需要的記憶體空間:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">#include &lt;stdio.h&gt;
 
int main()
{
printf("size of a short is %d\n", sizeof(short));
printf("size of a int is %d\n", sizeof(int));
printf("size of a long is %d\n", sizeof(long));
}</pre>
<p><a href="http://codepad.org/iQqRmLnh">在 codepad.org 執行上述 C 程式</a></p>
<p><span>當我們宣告一個變數時, 亦即告知編譯器兩件事, 變數名稱與變數型別. 例如, 可以透過:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">int k;</pre>
<p>宣告名稱為 k 的整數型別變數. 當編譯器看到 "int" 的敘述值, 就會在電腦的記憶體中, 保留 4 位元的空間, 以便存放整數變數 k 的值.</p>
<p>此外, 電腦也會設置一個符號表, 註明符號 k 與其在記憶體中用來存放 4 位元資料的相對位址.</p>
<p>因此, 若在變數宣告後, 使用:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">k = 2;</pre>
<p>2 這個數值, 就會在程式執行時, 被放在保留給 k 變數的記憶體位址中.</p>
<p>在 C 語言中, 整數 k 變數, 可視為一個物件. 其中有兩個值與物件 k 有關, 也就是存放的數值與存放的位址. 有些參考書中將者兩個數值稱為"右值"與"左值". (2 為右值, 而變數位址為左值)</p>
<p>在某些語言中, 左值只能放在指定"等號"的左邊, 而右值則只能放在右邊. 位置放錯, 例如:&nbsp;</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">2 = k;</pre>
<p>就會出錯.</p>
<p>其實, C 語言中有關左值得定義, 根據 K&amp;R II (page 197): [1], 則有些變動.</p>
<p>"物件為儲存區域的名稱, 而左值則為指向該物件的表示式."</p>
<p>這裡先採引用的定義加以說明, 後續將會進一步針對指標加以說明.</p>
<p>接著, 假如程式碼為:</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">int j, k;
k = 2; 
j = 7;    &lt;-- line 1 
k = j;    &lt;-- line 2</pre>
<p>編譯器會將第一行 (line 1) 的 j 解讀為變數 j 的位址 (也就是左值), 並且將值 7 放到該位址. 在第二行 (line 2), 則會將 j 視為右值 (因為在"指定"運算子的右方), 指的則是存放在 j 記憶體中的 7 這個數值. 因此第二行執行過後, 存放在 j 的 7 這個數值, 就會被放到 k 變數所對應的"左值" (記憶體位址) 中.</p>
<p>在這些範例中, 採用的都是將右值從一個儲存位址, 經由複製將 4 位元的資料複製到另外一個儲存位址. 假如使用 2 位元整數, 則會複製 2 位元資料.</p>
<p>這裡, 就會需要一種變數, 用來存放左值 (記憶體位址). 存放此一變數的值, 隨系統而異, 舊的桌上電腦總共只有 64K 的記憶體, 每存放一個整數位址會佔去 2 位元.</p>
<p>更多位元數的電腦 (例如 64 位元電腦), 則需要更多的位元位址來存放一個整數資料.</p>
<p>實際需要的記憶體大小並不重要, 需要的則是一種方法, 通知編譯器在哪一位址存放哪些資料.</p>
<p>這樣的變數稱為"指標變數" (隨後將說明得更清楚). 在 C 語言中定義指標變數時, 必須在變數名稱前方, 加上一個 * 符號. 而這些指標變數的型別, 隨著要存放在指標位址中的資料型別而定, 例如, 假如宣告:</p>
<p>int *ptr;</p>
<p>ptr 為變數名稱 (與之前的整數變數名稱 k 相同). 而 "*" 符號則告知編譯器, 此一宣告為指標變數, 亦即保留出足夠的記憶體存放位址. 最前方的 int 則表示, 希望此一指標變數用來存放整數. 而此一指標稱為"指向整數". 需要特別注意的是, 當使用 int k; 時並沒有給 k 初始值, 只有在任何符合 ANSI 規範的編譯器中, 會將宣告在函式外的變數通通以 0 初始.</p>
<p>同樣地, ptr 也沒有初始值, 亦即, 還沒有在上述宣告之後, 在保留的位址空間上, 放入任何值. 這裡若宣告是在任何函式之外, 就會被賦予初值, 並且保證不會指向任何 C 物件或函式. 以這種方式初始的指標, 被稱為 "空"指標 (null pointer).</p>
<p>而空指標並不一定會被放入 "0" 值, 因為這取決於特定系統中的設定. 為了在不同系統中的不同編譯器彼此相容, 就會利用巨集 (macro) 來表示空指標. 此巨集以 NULL 命名. 因此, 若以 NULL 設定指標值, 則可以確定在不同機器上, 這些指標變數一定是空指標.</p>
<p>與整數是否為 0 的判斷式 if(k ==0) 相類似, 可以利用 if(ptr == NULL) 判斷是否 ptr 為空指標.</p>
<p>但是, 回到新變數 ptr 的應用, 假設要將整數變數 k 所對應的位址, 存入 ptr, 就必須使用"位址運算子", 寫成:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">ptr = &amp;k;</pre>
<p>"位址運算子"的作用是用來取 k 的左值 (位址), 即使這時 k 位於等號右邊, 上述程式會將 k 的值複製到指標 ptr 的儲存空間中. 這時, ptr 稱為"指向" k.</p>
<p>接著再討論另外一個運算子.</p>
<p>也就是所謂的"取值運算子" (dereferencing operator), 就是一個 * 符號. 使用方法如下:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">*ptr = 7;</pre>
<p>這一行程式會將 7 這個數值,複製到 ptr 變數所指向的位址. 也就是說, 假如 ptr 指向 k (ptr 為 k 存放資料的記憶體位址), 這行程式就會將 k 的值設為 7. 換言之, * 運算子可用來改變 ptr 所指向的值, 而不是指標本身的值. (註:指標本身為位址, 也就是所謂的左變數)</p>
<p>因此, 可以利用:</p>
<p>printf("%d\n",*ptr);</p>
<p>將目前存放在 ptr 所指向位址的整數值, 透過 printf() 函式印到螢幕.</p>
<p>要釐清上述說明, 可以執行下列程式, 並仔細探討程式碼與其輸出.</p>
<p><span>------------ Program 1.1 ---------------------------------</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">/* Program 1.1 from PTRTUT10.TXT   6/10/97 */
 
#include &lt;stdio.h&gt;
 
int j, k;
int *ptr;
 
int main(void)
{
    j = 1;
    k = 2;
    ptr = &amp;k;
    printf("\n");
    printf("j has the value %d and is stored at %p\n", j, (void *)&amp;j);
    printf("k has the value %d and is stored at %p\n", k, (void *)&amp;k);
    printf("ptr has the value %p and is stored at %p\n", ptr, (void *)&amp;ptr);
    printf("The value of the integer pointed to by ptr is %d\n", *ptr);
 
    return 0;
}</pre>
<p><a href="http://codepad.org/w8R9mp9h">在 codepad.org 執行 Program 1.1</a></p>
<p>請注意: 我們還沒有談到 C 程式中的 (void *) 表示式. 這裡可以先納入您的測試程式碼中, 隨後將會加以說明.</p>
<p>結論:</p>
<ol>
<li><span class="nt">變數宣告必須指定名稱與型別</span><span class="o">.</span> <span class="o">(</span><span class="nt">例如</span><span class="o">:</span> <span class="nt">int</span> <span class="nt">k</span><span class="o">;)</span></li>
<li><span class="nt">指標變數宣告也是指定名稱與型別</span><span class="o">.</span> <span class="o">(</span><span class="nt">例如</span><span class="o">:</span> <span class="nt">int</span> <span class="o">*</span><span class="nt">ptr</span><span class="o">;),</span> <span class="nt">其中的</span> <span class="o">*</span> <span class="nt">告知編譯器</span><span class="o">,</span> <span class="nt">該名稱為</span> <span class="nt">ptr</span> <span class="nt">的變數</span><span class="o">,</span> <span class="nt">為一個指標變數</span><span class="o">,</span> <span class="nt">而其型別為該指標指向的資料型別</span> <span class="o">(</span><span class="nt">這裡為整數</span><span class="o">).</span></li>
<li><span class="nt">一旦變數已經宣告</span><span class="o">,</span> <span class="nt">可以透過變數前方的位址運算子</span><span class="o">,</span> <span class="nt">取得其位址</span><span class="o">,</span> <span class="nt">例如</span> <span class="o">&amp;</span><span class="nt">k</span><span class="o">.</span></li>
<li><span class="nt">可以由指標中</span><span class="s2">"取值"</span><span class="o">,</span> <span class="nt">亦即</span><span class="o">,</span> <span class="nt">以</span> <span class="o">*</span> <span class="nt">指定到指標所參照的值</span><span class="o">,</span> <span class="nt">例如</span><span class="o">:</span> <span class="o">*</span><span class="nt">ptr</span><span class="o">.</span></li>
<li><span class="nt">變數的左值為被用來存放在記憶體中的位址值</span><span class="o">,</span> <span class="nt">而變數的右值則式被存放在該位址的數值</span><span class="o">.</span></li>
</ol>
<p>參考資料:</p>
<p>"The C Programming Language" 2nd Edition B. Kernighan and D. Ritchie Prentice Hall ISBN 0-13-110362-8</p>
<p>第二章: 指標型別與陣列</p>
<p>接著讓我們來看看, 為何需要指定指標指向變數的型別, 例如: int *ptr; 原因之一是, 宣告之後, 可以透過指向, 寫成:</p>
<p>*ptr = 2;</p>
<p>編譯器就會知道要配置多少記憶體給 ptr 變數, 假如 ptr 宣告為指向整數, 電腦就會複製 4 位元的資料, 其它的浮點與雙浮點變數也是相同. 定義指向變數型別的另外一個用途就是編譯器可以解譯程式碼. 例如, 記憶區中存放 10 個連續的整數資料時, 需要 40 位元的記憶體.</p>
<p>假如整數指標 ptr 為這些整數中的第一個變數, 若該整數位於記憶體位址 100. 當程式寫為:</p>
<p>ptr + 1;</p>
<p>因為編譯器知道 ptr 為一個指標變數 (亦即, 其值為一組位址)並且指向某一整數 (目前位址為 100, 即是該整數所在位址), 當 ptr 加上 4 而不是 1 之後, 該指標將會指向下一個整數, 也就是記憶體 104.</p>
<p>相同的概念下, 若 ptr 指向短整數, 則應該加上 2 而不是 1. 對於浮點, 雙浮點或使用者自訂的資料型別 - 結構, 也是類似.</p>
<p>儘管這並非我們常見的"加法", 但是在 C 語言中, 可以透過指標算數進行"加法"運算, 隨後將會再予以說明.</p>
<p>同理, 因為 ++ptr 與 ptr++ 與 ptr + 1 等同 (儘管 ptr 增量的時機點並不一樣).</p>
<p>讓指標以 ++ 增量運算子進行增量, 無論是先加或後加, 由 sizeof(type) 中所得到的位址增量, 其型別均為該物件指向變數的型別 (整數為 4 位元).</p>
<p>由於這 10 個整數位於記憶體中連續區塊上, 指標可以被用於整數資料陣列的處理.</p>
<p>例如:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">int my_array[] = {1,23,17,4,-5,100};</pre>
<p><span>陣列中帶有 6 個整數. 可以透過 my_array 的索引代表這些整數. 亦即利用 my_array[0] 到 my_array[5] 加以表示, 也可以透過指標加以表示成:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">int *ptr;
ptr = &amp;my_array[0];       /* 將指標指向陣列中的第一個整數*/</pre>
<p>接著就可以使用陣列索引或取值運算, 列出陣列.</p>
<p>下列程式可以用來展示此一應用:</p>
<p>----------- Program 2.1 -----------------------------------</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">/* Program 2.1 from PTRTUT10.HTM   6/13/97 */
 
#include &lt;stdio.h&gt;
 
int my_array[] = {1,23,17,4,-5,100};
int *ptr;
 
int main(void)
{
    int i;
    ptr = &amp;my_array[0];     /* point our pointer to the first
                                      element of the array */
    printf("\n\n");
    for (i = 0; i &lt; 6; i++)
    {
      printf("my_array[%d] = %d   ",i,my_array[i]);   /*&lt;-- A */
      printf("ptr + %d = %d\n",i, *(ptr + i));        /*&lt;-- B */
    }
    return 0;
}</pre>
<p><a href="http://codepad.org/3fgCKs7N">在 codepad.org 執行 Program 2.1</a></p>
<p>編譯執行上列程式就可以仔細觀察 A 行與 B 行程式分別採用兩種方法列出陣列中的同一內容.</p>
<p>也可以清楚看到 B 行程式如何應用"取值"運算, 亦即, 首先在指標增量後, 在新的指標中取值. 將 B 行程式改為:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">printf("ptr + %d = %d\n",i, *ptr++);</pre>
<p><span>之後再執行, 接著改為:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">printf("ptr + %d = %d\n",i, *(++ptr));</pre>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">再執行, 執行之前先判定結果, 並與實際執行結果進行比較.

在 C 語言, 可以利用 var_name 來替代 &amp;var_name[0], 因此在程式碼中寫成:</pre>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">ptr = &amp;my_array[0];</pre>
<p><span>或:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">ptr = my_array;</pre>
<p>都會得到相同的結果.</p>
<p>因此許多參考書都寫道: 陣列的變數名稱就是指標. 但是比較好的想法則是: 陣列的變數名稱就是陣列中第一元件的位址. 許多初學者 (包含作者本人), 都會將其視為指標.</p>
<p>但是, 可以寫成:</p>
<p>ptr = my_array;</p>
<p>但是卻不能寫成:</p>
<p>my_array = ptr;</p>
<p>原因就是 ptr 為變數, 但是 my_array 卻是常數, 也就是說, my_array 第一元件的位址, 一旦在 my_array[] 完成宣告後, 就不可以改變.</p>
<p>先前曾討論的左值, 中引用 K&amp;R-2 中所言:</p>
<p>"物件為儲存區域的名稱, 而左值則為指向該物件的表示式."</p>
<p>這就衍生出一個有趣的議題. 因為 my_array 為儲存區域的代表名稱, 為何 my_array 在上面的指定敘述程式中, 卻不能用在左值區域?</p>
<p>為了說明這點, 可以將 my_array 視為"不可改變的左值".</p>
<p>上列範例可以將:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">ptr = &amp;my_array[0];</pre>
<p><span>改為:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">ptr = my_array;</pre>
<p>確認兩者會得到相同的結果.</p>
<p>至於 ptr 與 my_array 之間的差異, 有人將陣列變數名稱視為"常數指標". 為了充分了解所謂"常數"的真諦, 重回變數定義時的說明.</p>
<p>當變數宣告時, 用來存值的記憶體就必須加以配置. 這時變數可以透過兩個層面來看.</p>
<p>用在指定運算左邊時, 編譯器會視其為記憶位址, 用來指向右側所設定的值.</p>
<p>若被用在運算右邊時, 變數名稱會被解讀為存在該記憶體中的值.</p>
<p>有了以上的概念, 關注簡單的常數運算:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">int i, k;
i = 2;</pre>
<p>其中 i 為存放 2 常數的變數, 並非直接在資料記憶區塊中指定, 而是直接存入程式記憶區塊.</p>
<p>當 k = i; 程式碼就會到 &amp;i 位址中抓取要複製到 k 的值, 而 i = 2; 只是將 2 放入程式碼, 而沒有取值的運作. 也就是說, k 與 i 都是物件, 但是 2 則非物件.</p>
<p>同理, 由於 my_array 為常數 (為位址值), 一旦編譯器設好用來存值得區域後, my_array[0] 存值得記憶體位址就已經確定, 因此可以使用:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">ptr = my_array;</pre>
<p>將此在程式區段中的常數位址設給 ptr, 其中並沒有牽涉到資料區段的取值操作.</p>
<p>這時就可進一步說明第一章程式 1.1. 中 (void *) 的應用. 由於指標可被用來指向各種資料型別. 除了可以指向整數, 也可以指向字元, 之後還會介紹指向結構與指向指標的指標變數.</p>
<p>由於在不同系統中的指標儲值大小會有差別, 並且指標的記憶體空間會隨著指向物件資料型別差異而有所不同.</p>
<p>因此若將長整數指給短整數資料型別變數時, 就會發生問題, 也可以將某一型別的指標變數指定給其他不同型別指標變數時, 產生問題.</p>
<p>為了克服此一問題, C 語言提供 void 這個空的指標資料型別.</p>
<p>假如將某一指標設定為:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">void *vptr;</pre>
<p>空指標可以視為通用指標. 由於 C 語言不允許整數型別指標與字元型別指標之間的資料交換或比較. 這時就可以透過空指標作為中介, 在特殊情況下在指標型別間進行資料轉換.</p>
<p>在第一章的 1.1 程式中, 就是使用空指標將整數指標轉成能與 %p 資料相符的格式.</p>
<p>下列各章, 也將透過此一概念進行資料轉換.</p>
<p>這裡列出許多技術資料給初學者, 首次閱讀時或許不很容易理解. 因此需要前後執行幾次程式, 看看結果, 並且仔細查驗這兩個例子中的程式碼與產出結果, 才會有所突破.</p>
<p>接下來, 將討論指標, 字元陣列與字串間的關係.</p>
<p>第三章: 指標與字串</p>
<p>字串的研究不僅對進一步理解指標與陣列的關聯有些幫助,也能用來彰顯某些標準 C 字串函數的使用. 最後也可以理解指標如何將資料傳給函式.</p>
<p>就 C 而言, 字串為字元所組成的陣列, 其他的語言則未必如此. 無論是 BASIC, Pascal 或是 Fortran 與其他幾種程式語言, 字串自有其資料類別. C 則不然, 字串之於 C 被表為以 0 位元 (寫為'\0').</p>
<p>這裡要以幾行程式碼作為開端, 來加以說明, 如下:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">char my_string[40];

my_string[0] = 'T';
my_string[1] = 'e';
my_string[2] = 'd':
my_string[3] = '\0';</pre>
<p>或許沒有人會用這種方法來建立字串, 以空字元作為結尾. 根據 C 語言的定義, 字串為一組以空字元結尾的字元陣列. 注意這裡的所謂空字元與 "NULL" 不同. 空字元表為以跳脫序 '\0' 表示的"零"字元. 亦即佔了記憶體中的一個位元, 而 NULL 則為用來起始空指標的巨組程式.</p>
<p>NULL 在 C 編譯器中, 以 #define 在標頭檔案中宣告, 而 nul 則完全無法以 #define 宣告.</p>
<p>由於用上述程式來宣告字串非常累人, 因此 C 允許以多種方法來完成一項工作.</p>
<p>首先, 可以寫成</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">char my_string[40] = {'T', 'e', 'd', '\0',};</pre>
<p><span>但是光打字就有些不方便, 因此也可以寫成:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">char my_string[40] = "Ted";</pre>
<p>若使用的是雙引號, 而不是先前的單引號, 空字元 ('\0') 會自動被加在字串最後面.</p>
<p>上面的例子, 結果都相同. 編譯器會保留連續的 40 位元區塊來存放 Ted\0 這四個字元.</p>
<p>接著看看下列程式:</p>
<p>------------------program 3.1-------------------------------------</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">/* Program 3.1 from PTRTUT10.HTM   6/13/97 */
 
#include &lt;stdio.h&gt;
 
char strA[80] = "A string to be used for demonstration purposes";
char strB[80];
 
int main(void)
{
 
    char *pA;     /* a pointer to type character */
    char *pB;     /* another pointer to type character */
    puts(strA);   /* show string A */
    pA = strA;    /* point pA at string A */
    puts(pA);     /* show what pA is pointing to */
    pB = strB;    /* point pB at string B */
    putchar('\n');       /* move down one line on the screen */
    while(*pA != '\0')   /* line A (see text) */
    {
        *pB++ = *pA++;   /* line B (see text) */
    }
    *pB = '\0';          /* line C (see text) */
    puts(strB);          /* show strB on screen */
    return 0;
}</pre>
<p>--------- end program 3.1 -------------------------------------</p>
<p><a href="http://codepad.org/VohQ499U">在 codepad.org 執行 Program 3.1</a></p>
<p>上述程式定義了兩個字元陣列, 各有 80 字元. 由於屬於全域變數, 一開始各字元都填入 '\0'. 然後, strA 前 42 個字元被放入所引用的字串內容.</p>
<p>接著的程式碼, 宣告兩個字元指標並將其字串顯示在螢幕. 將 pA 指標指向 strA, 也就是附註 strA[0] 的位址給變數 pA. 然後利用 puts() 函數顯示 pA 所指向的內容 puts() 函式的宣告為:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">int puts(const char *s);</pre>
<p>現在先不用管 const, 傳給 puts() 函數的變數為指標. 其實是指標所對應的值. 而指標的值為其所指向的位址. 因此寫成 puts(strA), 表示輸入變數為 strA[0] 的位址.</p>
<p>同理, 當程式寫 puts(pA); 也是以相同的位址當作輸入, 因為已經透過</p>
<p>pA = strA;</p>
<p>將位址傳給 pA</p>
<p>因此程式執行到 while() 指令中的 A 行時, A 行內容為:</p>
<p>當 pA 所指向的字元並非 nul 字元時 (也就是'\0'), 執行其內容:</p>
<p>而 B 行程式則表示: 將 pA 指向的字元複製給 pB 所指向的字元, 接著增量 pA 後可以指向下一字元, 而 pB 則會指向下一個記憶體空間.</p>
<p>完成最後一個字元複製後, pA 會指向空字元, 也會終止迴圈的執行.</p>
<p>其中空字元並沒有複製, 但由於 C 中的字串一定要以空字元結尾, 所以在 C 行程式中再補上空字元.</p>
<p>執行此一程式時, 當使用者透過除錯器看著 strA, strB, pA 與 pB 一步步執行, 將非常具有教育意義.</p>
<p>It is even more educational if instead of simply defining strB[] as has been done above, initialize it also with something like:</p>
<p>更有意思的是, 若不將 strB[] 按上述方法定義時, 而是將其起始值設為:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">strB[80] = "12345678901234567890123456789012345678901234567890"</pre>
<p>讓其數字個數大於 strA 的長度, 然後一步步看著這些變數設定數值. 大家一定得親自做做看.</p>
<p>接著再回到 puts() 的原型, 運用 "const" 作為某一參數的宣告飾詞時, 主要在告訴使用者, 該函式無法改變其由 s 所指向的字串值, 意即, 程式會將該字串視為常數.</p>
<p>誠然, 上述程式展示了複製字串的一種簡單方式. 一旦確實了解上述程式的用法, 接著將自行編寫可以取代標準 strcpy() 的 C 標準函式, 程式如下:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">char *my_strcpy(char dest[], char source[])
{
    int i = 0;
    while (source[i] != '\0')
    {
        dest[i] = source[i];
        i++;
    }
    dest[i] = '\0';
    return dest;
}</pre>
<p>在此一程式中, 同樣運用了指標的傳值.</p>
<p>承上述內容, 若將函式寫成可以接受兩個字元指標變數輸入, 也就是位址, 就可以將上述程式改寫為:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">int main(void)
{
    my_strcpy(strB, strA);
    puts(strB);
}</pre>
<p><span>雖然與標準 C 的用法有些不同, 採用了下列原型定義:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">char *my_strcpy(char *destination, const char *source);</pre>
<p><span>之所以使用 "const" 飾詞, 主要在確定該函式無法變更指向來源指標的數值. 此點可從上述函式的修改得到印證, 其原型變數, 如 "const" 飾詞所示. 接著在函式中, 增加一行試圖更改該變數由來源指標所指向的值, 意即:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">	
*source = 'X';</pre>
<p>試著將該字串的第一個字元, 變更為 X. 前面的 const 飾詞就會讓這一行程式產生錯誤, 執行完後就會更加清楚有關 const 變數的使用.</p>
<p>接著, 繼續探討上述程式的內涵, 第一步, 將&nbsp;ptr++ 解讀為由 ptr 指標傳回值後的增量. 主要與運算子的次序有關. 假如寫成 (ptr)++, 表示增量的部分, 並非指標, 而是該指標所指向值的增量. 也就是說, 在上述程式中, 若對第一個字元 'T' 增量, 其值就會變成 'U'. 使用者可以自行寫程式來印證此一結果.</p>
<p>由於字串只不過就是字元所組合而成的陣列, 並在最後一個字元補上 '\0'. 上面所進行的是用來複製陣列. 這些字元陣列的運算技巧, 也可以應用到整數陣列或浮點數陣列. 但是在這些應用中, 陣列的尾端, 並不會補上 nul 字元, 而可以放進某特定值的內容, 來表示其為終點. 例如, 可以在複製正整數時, 在尾數放入一個負值的整數來標示終點. 或者, 寫一個函式, 可以複製字串以外的陣列及其陣列位址, 就如同下列原型所示:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">	
void int_copy(int *ptrA, int *ptrB, int nbr);</pre>
<p>其中 nbr 為要進行複製的整數值. 試著寫一個可以用來複製整數陣列的 int_copy() 函式, 看看是否能夠正常運作.</p>
<p>如此, 就可以使用函式來處理大陣列. 例如, 有一帶有 5000 個整數的陣列需要處理, 只要將該陣列的位址輸入該函式 (視情形, 可以加上其他相關變數, 如上述程式中的 nbr 變數), 而不需要輸入陣列本身, 意即, 整個陣列值並沒有在堆疊中複製後進行輸入的動作, 而只送出其位址.</p>
<p>此一過程與輸入某一整數給某一函式不同. 輸入整數時, 必須複製該整數, 也就是取得該整數的值, 然後放入某一堆疊當中. 這時, 該函式的處理並不影響原始的整數值, 而若以陣列及指標進行處理, 可以將變數位址輸入, 直接處理原始變數的值.</p>
<p>第四章: 更多關於字串的用法</p>
<p>好的, 在短短的時間裏, 已經介紹了不少東西! 接著再看一次第三章中有關字串複製的部分, 但是採不同的方法. 以下列函式來看:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">char *my_strcpy(char dest[], char source[])
{
    int i = 0;
    while (source[i] != '\0')
    {
        dest[i] = source[i];
        i++;
    }
    dest[i] = '\0';
    return dest;
}</pre>
<p>之前曾說過, 字串就是字元所組成的陣列. 這裡我們利用陣列表示而非指標表示, 來進行資料的實質複製. 結果會與之前相同, 亦即, 採此一方法的字串複製, 其結果依然正確. 這也衍生出接下來要討論的有趣論點.</p>
<p>由於變數透過值進行傳遞, 可經由前述之字元指標或陣列名稱進行, 其間真正傳遞的則是每一陣列中第一個元素的位址. 亦即, 變數數值的傳遞, 可透過字元指標或陣列名稱來代表此一變數. 也可以說, source[i] 其實與 *(p+i) 的用法一樣.</p>
<p>事實上, 這是正確的, 亦即 a[i] 可以利用 *(a+i) 來替代, 而不會產生任何問題. 換言之, 編譯器針對這兩種情形, 會產生相同的編碼. 因此, 指標算術其實與陣列索引編碼相同. 兩種語法會產生相同結果.</p>
<p>但是這並非說, 指標與陣列是相同的東西, 其實不然. 這裡只是說, 利用陣列來進行特定元素辨識, 可以採用兩種不同的語法, 其一為採用陣列索引, 而另一種方法則是利用指標算術, 會得到相同的結果.</p>
<p>接著, 注意最後的表示式, (a+i) 的部分利用簡單的加號 + 與 C 的語法, 表示式子可以交換, 亦即 (a+i) 與 (i+a) 完全相同. 因此可以將 (i+a) 簡化為 (a+i).</p>
<p>但是 *(i+a) 可能來自 i[a]! 綜合上述, 或許會懷疑若:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">char a[20];
int i;</pre>
<p><span>寫成:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">a[3] = 'x';</pre>
<p><span>其實與下列表示式, 其實是一樣的.</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">3[a] = 'x';</pre>
<p>試試看! 設定一個字元陣列, 內存為整數或長整數等. 對其第三或第四元素, 以傳統方式, 給定特殊值, 接著將值印出加以確認. 然後如前述, 將陣列表示式反轉過來, 一個好編譯器將會毫無疑問的給出相同的結果, 僅只出於好奇, 別無其他用意.</p>
<p>程式範例:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">#include &lt;stdio.h&gt;
 
// 每一個 C 程式都必須要有一個小寫的 main()函式
int main()
{
    // 陣列與指標的應用
    char a[20];
    int i;
    a[3] = 'x';
    printf("%c\n",a[3]);
    printf("%c\n",3[a]);
    printf("%c\n",*(a+3));
    printf("%c\n",*(3+a));
    return 0;
}</pre>
<p><a href="http://codepad.org/38P12lsx">執行上述程式</a></p>
<p>接著, 來看前面給的函數, 寫成:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">dest[i] = source[i];</pre>
<p><span>由於已知陣列索引與指標算術會得到相同的結果, 因此也可以寫成:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">*(dest + i) = *(source + i);</pre>
<p>但是, 需要對每一個值分別加上 i. 加法, 一般而言, 會比索引增量 (例如採用 ++ 運算符號的 i++) 耗費更多時間. 或許對現在最佳化的編譯器來說, 不一定就是如此, 但是採用指標通常比陣列索引來得快些.</p>
<p>另一個可以加速指標運算的方法, 將:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">	
while (*source != '\0')</pre>
<p><span>簡化為:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">while (*source)</pre>
<p>兩種情形都會讓括號中為零 (FALSE).</p>
<p>這裡可實驗看看, 以指標的方法來寫程式. 用來處理字串應該不錯. 可以將下列標準函式改寫成自己的版本:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">strlen();
strcat();
strchr();</pre>
<p>或者其他在系統中的函式.</p>
<p>接下來的章節, 還會再探討字串及其處理. 接下來先討論一下 structures (結構).</p>
<p>第五章: 指標與結構</p>
<p>也許你已經知道, 可以利用結構的形式來宣告帶有不同資料型別的資料區塊. 例如, 人事檔案可能包含下列結構:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">struct tag {
    char lname[20];        /* 姓 */
    char fname[20];        /* 名 */
    int age;               /* 年齡 */
    float rate;            /* 例如: 每小時 100 元 */
};</pre>
<p>假如在磁片檔案中有許多這樣的資料, 當我們需要一筆筆讀出, 並且分別列出姓名, 以做成資料表格. 其他資料並不需要印出. 具體做法, 可以利用函式呼叫, 透過指向結構的指標作為輸入, 就可以完成處理. 這裡只利用一個結構進行示範, 並且主要在編寫函式, 而非讀檔. 這裡已經假設您知道如何進行讀檔.</p>
<p>複習一下, 我們可以利用點運算子來擷取結構成員, 正如:</p>
<p>--------------- program 5.1 -----------------</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">/* Program 5.1 from PTRTUT10.HTM     6/13/97 */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
 
struct tag {
    char lname[20];      /* last name */
    char fname[20];      /* first name */
    int age;             /* age */
    float rate;          /* e.g. 12.75 per hour */
};
 
struct tag my_struct;       /* declare the structure my_struct */
 
int main(void)
{
    strcpy(my_struct.lname,"Jensen");
    strcpy(my_struct.fname,"Ted");
    printf("\n%s ",my_struct.fname);
    printf("%s\n",my_struct.lname);
    return 0;
}</pre>
<p>-------------- end of program 5.1 --------------</p>
<p><a href="http://codepad.org/yKWdNwEE">執行 Program 5.1</a></p>
<p>或許這裏所使用的結構與一般 C 程式所使用的相比還要小, 為了驗證也可以加入:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">date_of_hire;                  (未顯示資料型別)
date_of_last_raise;
last_percent_increase;
emergency_phone;
medical_plan;
Social_S_Nbr;
等等.....</pre>
<p>假如員工的數量眾多, 應該會採用函式進行資料處理. 例如, 將結構輸入該函式, 就能利用函式印出員工姓名. 但是在最原始的 C (Kernighan &amp; Ritchie, 第一版), 無法輸入結構, 只能輸入指向結構的指標. 在 ANSI C 中, 已經允許利用結構作為函式輸入. 而這裡為了進行更多有關指標的學習, 並不直接採用結構.</p>
<p>總之, 假如輸入整個結構, 就如同必須在函式呼叫時複製結構內容, 在仍然使用堆疊的系統中, 就等同將整個結構資料送入堆疊中. 針對大型結構時, 可能就會造成問題. 若能只輸入指標, 就可使用最少的堆疊空間.</p>
<p>因此這裡主要在談指標, 因此接著來看如何將指向結構的指標變數輸入函式當中.</p>
<p>以上面的情況為例, 建立一個能夠接受指標變數 (指向結構) 的函式, 其中我們只想要擷取該結構的部分成員. 例如, 只要印出範例結構中的人員姓名.</p>
<p>好, 先前我們已經知道如何宣告指向結構的指標變數 tag. 接著就可以利用 tag 結構, 來宣告指標變數:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">struct tag *st_ptr;</pre>
<p><span>並且可以用來指向範例中的結構:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">st_ptr = &amp;my_struct;</pre>
<p><span>接下來, 可以利用指標的分割參照, 來指定特定成員. 但是應該如何利用指標的分割參照來指向結構? 假如要利用指標來設定人員的年紀, 可以寫成:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">(*st_ptr).age = 63;</pre>
<p>仔細看清楚. 此一設定表示, 若將括號中 st_ptr 所指向的內容換成 my_struct, 就會與my_struct.age 相同.</p>
<p>但是, 這樣經常會被用到的表示式, 就被設定為與下列表示式涵義相同:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">st_ptr-&gt;age = 63;</pre>
<p>了解了之後, 參考下列程式:</p>
<p>------------ program 5.2 ---------------------</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">/* Program 5.2 from PTRTUT10.HTM   6/13/97 */
 
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
 
struct tag{                     /* the structure type */
    char lname[20];             /* last name */
    char fname[20];             /* first name */
    int age;                    /* age */
    float rate;                 /* e.g. 12.75 per hour */
};
 
struct tag my_struct;           /* define the structure */
void show_name(struct tag *p);  /* function prototype */
 
int main(void)
{
    struct tag *st_ptr;         /* a pointer to a structure */
    st_ptr = &amp;my_struct;        /* point the pointer to my_struct */
    strcpy(my_struct.lname,"Jensen");
    strcpy(my_struct.fname,"Ted");
    printf("\n%s ",my_struct.fname);
    printf("%s\n",my_struct.lname);
    my_struct.age = 63;
    show_name(st_ptr);          /* pass the pointer */
    return 0;
}
 
void show_name(struct tag *p)
{
    printf("\n%s ", p-&gt;fname);  /* p points to a structure */
    printf("%s ", p-&gt;lname);
    printf("%d\n", p-&gt;age);
}</pre>
<p>-------------------- end of program 5.2 ----------------</p>
<p><a href="http://codepad.org/BTNjPXRy">執行 Program 5.2</a></p>
<p>這裡要了解不少東西. 讀者必須實際執行一下上面的程式, 並且利用除錯器一步步觀察 my_struct 與 p 在主函式執行流程中, 才能實際了解函式執行的內容.</p>
<p>第六章: 更多關於字串與字串陣列的用法</p>
<p>接著, 再回到字串的用法. 下面的例子, 都以全域的方式運用, 亦即, 在任何函式之外發生作用, 包括主函式.</p>
<p>先前的章節曾經談過:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">char my_string[40] = "Ted";</pre>
<p>將會配置足夠存放 40 個位元組陣列的空間來存放該變數的值, 並且在最前面的 4 個位元組中放入所設定的字元 (前面三個位元組放入雙引號中的字元, 而最後則放入 '\0')</p>
<p>而實際上, 也可以將 "Ted" 這個字串寫成:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">char my_name[] = "Ted";</pre>
<p>編譯器屆時就會計算字元個數, 並且預留最後的 null 字元, 以便能將全部四個字元存入記憶體, 並傳回存放字元的陣列名稱, 這裡採用 my_name.</p>
<p>在某些程式中, 也可以寫成:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">char *my_name = "Ted";</pre>
<p>這種方式, 與先前兩種方法有何不同? 答案是: 當然不同. 採用陣列來存放四個位元組是將資料放在靜態記憶體區塊, 每一個字元的最後都會放入 null 字元. 但是若採用指標的方式, 也是需要相同的四個位元組, 並加上 N 個位元組來存放 my_name 這個指標變數 (N 取決於系統, 但通常至少 2 位元組, 也可能是 4 個以上)</p>
<p>陣列的表示法中, my_name 是 &amp;myname[0] 的縮寫, 也就是第一個陣列元素的位址. 由於該陣列位址在執行期間是固定的, 因此不會改變 (不是變數). 而若採用指標的方式, my_name 則是變數. 因此採用指標是較好的方式, 當然也取決於隨後要如何應用這個變數.</p>
<p>若再進一步觀察採用不同方式宣告後, 在函數內將如何發生變化, 這與處在任何函式外的全域用法有很大的不同.</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">void my_function_A(char ptr) { char a[] = "ABCDE" . . } void my_function_B(char ptr)</pre>
<p>在 my_function_A 的案例中, 陣列 a[] 的值, 就是存放其中的資料. 陣列可視為以 ABCDE 值進行啟始化. 而在 my_function_B 的案例, cp 指標值才代表所存放的資料. 指標的啟始是指向 FGHIJ 字串. 在兩個函式內, 變數定義都是局部, 因此 ABCDE 字串存在指標變數所對應值的堆疊中, 而 FGHIJ 則可能存在任何地方. 在我的系統中, 是存在資料區段中.</p>
<p>此外, 採陣列變數自動起始, 就如同 my_function_A 中所示, 在舊的 K&amp;R C 中是無法使用的, 只能用在 ANSI C 的環境中. 這點在考量程式的可攜或向後相容時就顯得很重要.</p>
<p>只要討論有關指標與陣列的關係與差異時, 就需要更進一步討論多維度陣列. 例如下列陣列:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">char multi[5][10];</pre>
<p><span>這代表什麼? 讓我們看看.</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">char multi[5][10];</pre>
<p>若將有底線的部分視為陣列的變數名稱. 先前的 char 代表資料型別, 而隨後的 [10] 則代表擁有時個字元的陣列. 但是 multi[5] 本身又是一個具有 5 個成員的陣列, 而每一個都帶有 10 個字元的陣列. 亦即, 總共有 5 個陣列各自帶有 10 個字元的陣列.</p>
<p>假設將這個二維的陣列填入資料, 在記憶體中, 可以表示成為五個各自分離的陣列:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">multi[0] = {'0','1','2','3','4','5','6','7','8','9'}
multi[1] = {'a','b','c','d','e','f','g','h','i','j'}
multi[2] = {'A','B','C','D','E','F','G','H','I','J'}
multi[3] = {'9','8','7','6','5','4','3','2','1','0'}
multi[4] = {'J','I','H','G','F','E','D','C','B','A'}</pre>
<p><span>同時, 個別元素可以再表示為:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">multi[0][3] = '3'
multi[1][7] = 'h'
multi[4][0] = 'J'</pre>
<p><span>由於陣列在記憶體中是連續的資料, 因此在真實的記憶區段中, 就成為:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">0123456789abcdefghijABCDEFGHIJ9876543210JIHGFEDCBA
^
|_____ starting at the address &amp;multi[0][0]</pre>
<p>請注意, 這裡並沒有將 multi[0] 寫成"0123456789". 因為若寫成這樣, 電腦會在最 後面補上字串結束用的 '\0', 因為雙引號中間的資料會被當作字串. 這樣, 每一個變數 就會帶有 11 個字元, 而非該有的 10 個字元.</p>
<p>前面的用意在昭示記憶體如何處理二維陣列. 亦即, 以一個二維字元陣列來存放資料, 而不是存成字串陣列.</p>
<p>接著, 編譯器知道陣列中需要多少行, 因此會用 mylti +1 作為 'a' 在第二列之首, 也就是每一列會加上 10, 結合所指的列數來取得正確的資料.</p>
<p>若處理的數值為整數與相同維數的陣列, 在我使用的機器上, 編譯器會加上 10sizeof(int), 而得到 20. 因此第四列第九行的位址, 表示為指標, 將會是 &amp;multi[3][0] 或 (multi + 3). 若希望取得第四列第二個數值, 就可以在此位址上加上 1, 得到下列結果:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">*(*(multi + 3) + 1)</pre>
<p><span>再繼續探究, 可知:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">*(*(multi + row) + col)    與

multi[row][col]            可得到相同的結果.</pre>
<p>下列程式採用整數數列而非字元陣列來驗證這個結果:</p>
<p>------------------- program 6.1 ----------------------</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">#include &lt;stdio.h&gt;
#define ROWS 5
#define COLS 10
 
int multi[ROWS][COLS];
 
int main(void)
{
    int row, col;
    for (row = 0; row &lt; ROWS; row++)
    {
        for (col = 0; col &lt; COLS; col++)
        {
            multi[row][col] = row*col;
        }
    }
 
    for (row = 0; row &lt; ROWS; row++)
    {
        for (col = 0; col &lt; COLS; col++)
        {
            printf("\n%d  ",multi[row][col]);
            printf("%d ",*(*(multi + row) + col));
        }
    }
 
    return 0;
}</pre>
<p>----------------- end of program 6.1 ---------------------</p>
<p><a href="http://codepad.org/flzRLrx1">執行 Program 6.1</a></p>
<p>由於在陣列程式版本中進行了兩次交互參照取值, 二維陣列的名稱就如同指向陣列的指標. 至於三維陣列則用來處理陣列中陣列所指向的陣列, 因此也等同是指向陣列中陣列的指標. 但這裡的說明將陣列所佔記憶體區段以陣列來加以表示, 因此所處理的記憶體位址為常數而非變數. 亦即所討論的是固定的位址而非變數指標.</p>
<p>上述的取值函式允許從陣列中, 以無需變更位址數值的方式從陣列中取出任何數值 (例如, 以 multi[0][0] 的位址取 multi 符號所對應的值)</p>
<p>CHAPTER 7: More on Multi-Dimensional Arrays</p>
<p>In the previous chapter we noted that given:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">#define ROWS 5
#define COLS 10

int multi[ROWS][COLS];</pre>
<p><span>we can access individual elements of the array multi using either:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">multi[row][col]</pre>
<p>or</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">((multi + row) + col)</pre>
<p><span>To understand more fully what is going on, let us replace</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">*(multi + row)</pre>
<p><span>with X as in:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">*(X + col)</pre>
<p>Now, from this we see that X is like a pointer since the expression is de-referenced and we know that col is an integer. Here the arithmetic being used is of a special kind called "pointer arithmetic" is being used. That means that, since we are talking about an integer array, the address pointed to by (i.e. value of) X + col + 1 must be greater than the address X + col by and amount equal to sizeof(int).</p>
<p>Since we know the memory layout for 2 dimensional arrays, we can determine that in the expression multi + row as used above, multi + row + 1 must increase by value an amount equal to that needed to "point to" the next row, which in this case would be an amount equal to COLS * sizeof(int).</p>
<p>That says that if the expression ((multi + row) + col) is to be evaluated correctly at run time, the compiler must generate code which takes into consideration the value of COLS, i.e. the 2nd dimension. Because of the equivalence of the two forms of expression, this is true whether we are using the pointer expression as here or the array expression multi[row][col].</p>
<p>Thus, to evaluate either expression, a total of 5 values must be known:</p>
<p>The address of the first element of the array, which is returned by the expression multi, i.e., the name of the array.</p>
<p>The size of the type of the elements of the array, in this case sizeof(int).</p>
<p>The 2nd dimension of the array The specific index value for the first dimension, row in this case. The specific index value for the second dimension, col in this case. Given all of that, consider the problem of designing a function to manipulate the element values of a previously declared array. For example, one which would set all the elements of the array multi to the value 1.</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">void set_value(int m_array[][COLS])
{
    int row, col;
    for (row = 0; row &lt; ROWS; row++)
    {
        for (col = 0; col &lt; COLS; col++)
        {
            m_array[row][col] = 1;
        }
    }
}</pre>
<p><span>And to call this function we would then use:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">set_value(multi);</pre>
<p>Now, within the function we have used the values #defined by ROWS and COLS that set the limits on the for loops. But, these #defines are just constants as far as the compiler is concerned, i.e. there is nothing to connect them to the array size within the function. row and col are local variables, of course. The formal parameter definition permits the compiler to determine the characteristics associated with the pointer value that will be passed at run time.</p>
<p>We really don&rsquo;t need the first dimension and, as will be seen later, there are occasions where we would prefer not to define it within the parameter definition, out of habit or consistency, I have not used it here. But, the second dimension must be used as has been shown in the expression for the parameter. The reason is that we need this in the evaluation of m_array[row][col] as has been described.</p>
<p>While the parameter defines the data type (int in this case) and the automatic variables for row and column are defined in the for loops, only one value can be passed using a single parameter. In this case, that is the value of multi as noted in the call statement, i.e. the address of the first element, often referred to as a pointer to the array. Thus, the only way we have of informing the compiler of the 2nd dimension is by explicitly including it in the parameter definition.</p>
<p>In fact, in general all dimensions of higher order than one are needed when dealing with multi-dimensional arrays. That is if we are talking about 3 dimensional arrays, the 2nd and 3rd dimension must be specified in the parameter definition.</p><br />機械設計 << <a href='機械設計.html'>Previous</a> <a href='工具.html'>Next</a> >> 工具</section></div></body></html>