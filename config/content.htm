<h1>簡介</h1><p><span style="background-color: #ffff00;">請注意: 在 2018.09 正式開課前, 本網站資料內容均尚未定案, 僅為參考草案.</span></p><p><a href="https://www.scipy-lectures.org/intro/intro.html">https://www.scipy-lectures.org/intro/intro.html</a>&nbsp;</p><p><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/optimize.html">https://docs.scipy.org/doc/scipy/reference/tutorial/optimize.html</a>&nbsp;</p><p><a href="https://github.com/m2n037/awesome-mecheng">https://github.com/m2n037/awesome-mecheng</a>&nbsp;</p><p><a href="http://download.qt.io/development_releases/qtcreator/4.7/4.7.0-rc1/">http://download.qt.io/development_releases/qtcreator/4.7/4.7.0-rc1/</a>&nbsp;</p><p><a href="https://wiki.qt.io/MSYS2">https://wiki.qt.io/MSYS2</a>&nbsp;</p><p><a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm</a>&nbsp;</p><p><a href="http://web.stanford.edu/dept/cs_edu/qt-creator/qt-creator-windows.shtml">http://web.stanford.edu/dept/cs_edu/qt-creator/qt-creator-windows.shtml</a>&nbsp;</p><p><a href="http://web.stanford.edu/class/archive/cs/cs106b/cs106b.1182/lectures/">http://web.stanford.edu/class/archive/cs/cs106b/cs106b.1182/lectures/</a>&nbsp;</p><p><a href="https://www.codestepbystep.com/about">https://www.codestepbystep.com/about</a>&nbsp;</p><p><a href="https://google.github.io/styleguide/cppguide.html">https://google.github.io/styleguide/cppguide.html</a>&nbsp;</p><p>&nbsp;編程指南:&nbsp;<a href="https://qtguide.ustclug.org/">https://qtguide.ustclug.org/</a>&nbsp;</p><pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">start /MIN cmd.exe /k "y:\cp2018.bat"cp2018.batcd /d c:\2018\cadp2018python wsgi.py</pre><p>課程目標:</p><p>為了讓機械設計工程師了解, 該如何利用電腦與網路進行機械設計. 總共安排了四門課程:</p><p>計算機程式 - 每一組六人, 分為 C, Python, Lua, Html5, CSS, Javascript 等六項學習任務, 並以共同任務: 可攜系統, Git, Fossil SCM, Windows 10 電腦, Ubuntu 電腦 與網路的技術學習, 利用計算機程式進行各種問題的解決.</p><p>最佳化設計問題:&nbsp;<a href="https://docs.scipy.org/doc/scipy/reference/tutorial/optimize.html">https://docs.scipy.org/doc/scipy/reference/tutorial/optimize.html</a>&nbsp;</p><p>網際內容管理 - 在 Windows 10 與 Ubuntu 電腦, 建立 CMSimfly 與 Pygrouf 環境.</p><p>電腦輔助設計實習 - 加入電腦輔助機械設計零組件繪製與機器人模擬與製作技術研習.</p><p>協同產品設計實習 - 全面利用近端與雲端資源的整合, 進行機電資產品開發.</p><p><a href="https://coggle.it/diagram/WzOQWjCAbuRWow6A/t/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A8%8B%E5%BC%8F/544030eebbbe4f0d10aff84c8ee2e10a8c36faa1270808c275dc189d98cfcc3e">2018 Fall 計算機程式課程規劃心智圖</a>&nbsp;(under scrum1 At mde)</p><p><a href="http://worrydream.com/#!/LearnableProgramming">http://worrydream.com/#!/LearnableProgramming</a>&nbsp;</p><p><a href="https://qmlbook.github.io/">https://qmlbook.github.io/</a>&nbsp;</p><p><a href="http://open.umn.edu/opentextbooks/">http://open.umn.edu/opentextbooks/</a>&nbsp;</p><p><a href="/downloads/Web%20Technology.pdf">web technology.pdf</a></p><p>計算機程式課程:</p><ol><li>不需要使用紙本資料:&nbsp; 所有教材都以數位形式存在.</li><li>要求學員編寫紙本筆記: 在訓練手到學習, 至少寫紙本筆記時, 手可以暫時離開手機:-)</li><li>採用版次管理系統: 能夠保存各階段的版本, 完成呈現事件的歷程資料.</li><li>透過網路協同: 多人可同步或非同步執行專案, 突破時間與空間的限制.</li><li>實作前模擬: 將機械與電子電機相關整合系統, 以資訊科技模擬呈現.</li><li>人工智慧應用: 車牌辨識、專家系統與創新設計, 計算機程式經歷輔助、引導, 已經逐步進入自主創新世代.</li></ol><p>學習 Python 與 PyQt 用於視窗程式開發:</p><p>利用 Python 與 PyQt 可開發 Windows 10 環境執行的視窗程式.&nbsp;</p><p>課程採用可攜程式系統, 使用者可以從 <a href="https://drive.google.com/open?id=1OBDoW2aYhN6jsf67dXSvV0wwnwXuJmYR">leo1807</a> 下載初步所需的隨身系統. 由於此系統採用最新的 Python 3.7.0 解譯器, 目前尚無法直接以 pip 安裝 pyqt5-tools 模組, 因此無法使用 Qt Designer 的圖形介面工具. 使得 Eric6 IDE 的導入暫時無法使用.</p><p>學習 C 用於 <a href="https://www.tinkercad.com/">Tinkercad</a> Arduino 控制卡模擬:</p><p>學習 Lua 用於 <a href="http://www.coppeliarobotics.com/">V-rep</a> 機器人模擬:</p><p><span>Lua is a powerful, fast, lightweight, embeddable scripting language.</span></p><p>學習 Javascript 與&nbsp; <a href="https://brython.info/">Brython</a> 與 <a href="https://github.com/fengari-lua/fengari-web">Fengari-web</a> 用於網頁動態模擬:</p><p><img src="/images/three_gears.png" width="790" height="367" alt=""></p><h2>機械設計</h2>
<p>機械設計與表達</p>
<p>設計是一種明確與具體的表達, 而且是在仔細思考、多方考量後所完成的表達, 表達具有六種形式, 包括口語、文字、2D、3D、數學與實體表達, 設計的結果可以讓執行者有所依循, 根據指示執行後, 可得預期之結果.</p>
<p>機械是一種器物, 而且是由固體、流體與軟體元件精巧組合而成, 可互動運作, 達成特定功能之器物.</p>
<p>因此機械設計就是靈活運用六種表達, 明確說明如何透過固體、流體與軟體元件之互動運作, 而能達成預定結果之明確與具體表達.</p>
<p>參與機械設計的工程師, 為順利完成任務, 解決產品開發過程所面臨的各項問題, 展現創造力的三種必備能力: 自學能力、執行能力與想像能力.</p>
<p>由於機械設計流程牽涉許多固體、流體與軟體元件配置, 而且當多名成員在協同設計過程中, 會於不同時間納入各種機械設計組成及六種表達內容, 因此必須要設法運用組態管理 (Configuration Management) 系統, 呈現各時間點詳細的組成內容與狀態.</p>
<h2>Pointer</h2>
<p>指標:&nbsp;<a href="http://cad-lab.github.io/manual/post/c-cheng-shi-yu-yan-de-zhi-biao-yu-zhen-lie-dao-yin-zhong-wen-fan-yi.html">http://cad-lab.github.io/manual/post/c-cheng-shi-yu-yan-de-zhi-biao-yu-zhen-lie-dao-yin-zhong-wen-fan-yi.html</a>&nbsp;</p>
<p>電腦中利用記憶體中的位址 (address) 來標示資料的儲存</p>
<p>pointer 與 pointer variable</p>
<p>pointer 為用來標示變數儲存的位址, 為整數常數</p>
<p>pointer variable 則是用來存放位址的變數稱為指標變數</p>
<p>&amp; 為取位址運算符 - 取變數的位址</p>
<p>*為指標運算符 - 從某一位址中取對應的數據</p>
<p>i_pointer 為一個指標變數</p>
<p>i 為整數變數</p>
<p>i_pointer&nbsp; = &amp;i&nbsp; = &amp;(*i_pointer)</p>
<p>i = *i_pointer =&nbsp; *(&amp;i)</p>
<h3>指標教材</h3>
<p>來源:&nbsp;<a href="http://pweb.netcom.com/~tjensen/ptr/pointers.htm">http://pweb.netcom.com/~tjensen/ptr/pointers.htm</a>&nbsp;</p>
<p>前言</p>
<p>本文件旨在向 C 程式語言的初學者介紹指標. 過去幾年, 無論是在 FidoNet 與 UseNet 有關 C 的會議場合, 特別注意到有許多 C 程式語言的初學者, 似乎對於指標的基本用法, 感到有些困難. 因此特別利用較多的範例, 希望以淺顯的說明來解釋指標的用法.</p>
<p>這份文件的第一版本, 如同此一版本, 是被放在公共領域. 當時是由 Bob Stout 將資料放在 PTR-HELP.TXT 的文件檔中, 並納入 SNIPPETS 的收集中加以發行. 之後, 又在原始資料中增添了許多內容並且修正了一些錯誤.</p>
<p>致謝</p>
<p>要感謝許多不為人知的使用者, 將許多問題公佈在 FidoNet 的 C Echo 論壇中, 或是 UseNet comp.lang.c 新聞群組中, 或是在其他網路上的幾個會議區,這些要感謝的人士可能無法一一列出. 其中特別要感謝 Bob Stout 肯將這份資料的第一版本放入他所收集的 SNIPPETS 檔案中.</p>
<p>關於作者:</p>
<p>Teb Jensen 是一位退休的電子工程師, 主要專注於電磁錄音領域中的硬體設計與管理職務. 程式則是自 1968 年以來閒暇時的興趣, 當時正學著如何以打卡的方式讓程式送給電腦主機執行. (那時的主機擁有 64 K 的磁心記憶體)</p>
<p>使用本資料:</p>
<p>這份資料以公共領域授權釋出. 任何人可以採用任何形式, 複製或散佈這份資料. 唯一的要求, 則是若這份資料被用於課程教學, 希望能夠完整呈現, 亦即, 包含所有章節, 包括前言與簡介.</p>
<p>並且任課教師能夠利用下方的電子郵箱通知我一聲. 之所以如此要求, 主要是希望這份資料能夠對其他人有用, 況且我並不要求金錢回報. 只是希望能夠透過使用這份資料的用戶回饋, 多少確認一下這個目標能夠達成.</p>
<p>此外, 並非一定要是課程教學者可以寫信給我. 感謝任何覺得此份資料有用或提供建設性批評的任何人, 都能告訴我一聲, 我將會透過電子郵件回答相關問題.</p>
<p><a href="https://en.wikipedia.org/wiki/Ted_Jensen">Ted Jensen</a><span>&nbsp;</span>tjensen@netcom.com P.O. Box 324 1-415-365-8452 Redwood City, CA 94064 Dec. 1995</p>
<p>簡介</p>
<p>若您想要專精於利用 C 程式語言編寫程式碼, 就必須徹底了解如何使用指標. 然而, C 指標對初學者而言, 經常是一項障礙, 尤其對於從 Fortran, Pascal 或 Basic 程式語言轉進的學習者.</p>
<p>這份資料旨在幫助初學者了解指標. 為了能讓這份資料發揮最大功能, 使用者最好能夠實際執行文章中所列出的各個程式. 因此所有的程式碼都採 ANSI 標準, 以便讓任何符合 ANSI 標準的編譯器都能執行這些程式碼. 內文與程式碼之間, 也特別加以區分開來, 以便使用者可以直接利用複製的方式, 取的各段落的程式碼, 套用到其他系統中進行編譯. 如此才能確實了解這裡所提供的資料.</p>
<p>第一章: 何謂指標?</p>
<p>C 語言初學者必須面對的難題之一, 就是指標的用法.</p>
<p>這份教材的目的, 就是針對初學者簡介指標及其應用.</p>
<p>其實初學者會對指標產生疑惑, 大多源自於在學習 C 語言時, 對於變數的概念經常一知半解.</p>
<p>因此這裡就由 C 變數的一般用法說起.</p>
<p>程式中的變數都必須加以命名, 以便存放數值.</p>
<p>而編譯器與連結器在處理變數時, 就會挪出電腦記憶體中的特定區域, 以存放變數的值</p>
<p>這些特定區域的大小, 取決於變數允許存放值的範圍.</p>
<p>例如, 在 32 位元電腦, 一個整數變數的存放範圍, 需要為 4 位元. 而在舊的 16 位元電腦, 整數存放需要 2 位元.</p>
<p>C 程式中的整數變數存放範圍大小, 在各種機器上不一定相同.</p>
<p>並且 C 程式中的整數變數也不只一種, 在許多 C 程式教科數中,可以發現有整數, 長整數, 短整數等. 這裡則假設使用 32 位元系統, 因此整數需要 4 位元的存放空間.</p>
<p>可以採用下列程式碼,在您所使用的系統中, 查探特定整數型別所需要的記憶體空間:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">#include &lt;stdio.h&gt;
 
int main()
{
printf("size of a short is %d\n", sizeof(short));
printf("size of a int is %d\n", sizeof(int));
printf("size of a long is %d\n", sizeof(long));
}</pre>
<p><a href="http://codepad.org/iQqRmLnh">在 codepad.org 執行上述 C 程式</a></p>
<p>當我們宣告一個變數時, 亦即告知編譯器兩件事, 變數名稱與變數型別. 例如, 可以透過</p>
<p>int k;</p>
<p>宣告名稱為 k 的整數型別變數. 當編譯器看到 "int" 的敘述值, 就會在電腦的記憶體中, 保留 4 位元的空間, 以便存放整數變數 k 的值.</p>
<p>此外, 電腦也會設置一個符號表, 註明符號 k 與其在記憶體中用來存放 4 位元資料的相對位址.宣告名稱為 k 的整數型別變數. 當編譯器看到 "int" 的敘述值, 就會在電腦的記憶體中, 保留 4 位元的空間, 以便存放整數變數 k 的值.<br>因此, 若在變數宣告後, 使用</p>
<p>k = 2;2 這個數值, 就會在程式執行時, 被放在保留給 k 變數的記憶體位址中.</p>
<p>在 C 語言中, 整數 k 變數, 可視為一個物件. 其中有兩個值與物件 k 有關, 也就是存放的數值與存放的位址. 有些參考書中將者兩個數值稱為"右值"與"左值". (2 為右值, 而變數位址為左值)</p>
<p>在某些語言中, 左值只能放在指定"等號"的左邊, 而右值則只能放在右邊. 位置放錯, 例如: 2 = k, 就會出錯.</p>
<p>其實, C 語言中有關左值得定義, 根據 K&amp;R II (page 197): [1], 則有些變動.</p>
<p>"物件為儲存區域的名稱, 而左值則為指向該物件的表示式."</p>
<p>這裡先採引用的定義加以說明, 後續將會進一步針對指標加以說明.</p>
<p>接著, 假如程式碼為:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">int j, k;
k = 2; 
j = 7;    &lt;-- line 1 
k = j;    &lt;-- line 2</pre>
<p>編譯器會將第一行 (line 1) 的 j 解讀為變數 j 的位址 (也就是左值), 並且將值 7 放到該位址. 在第二行 (line 2), 則會將 j 視為右值 (因為在"指定"運算子的右方), 指的則是存放在 j 記憶體中的 7 這個數值. 因此第二行執行過後, 存放在 j 的 7 這個數值, 就會被放到 k 變數所對應的"左值" (記憶體位址) 中.</p>
<p>在這些範例中, 採用的都是將右值從一個儲存位址, 經由複製將 4 位元的資料複製到另外一個儲存位址. 假如使用 2 位元整數, 則會複製 2 位元資料.</p>
<p>這裡, 就會需要一種變數, 用來存放左值 (記憶體位址). 存放此一變數的值, 隨系統而異, 舊的桌上電腦總共只有 64K 的記憶體, 每存放一個整數位址會佔去 2 位元.</p>
<p>更多位元數的電腦 (例如 64 位元電腦), 則需要更多的位元位址來存放一個整數資料.</p>
<p>實際需要的記憶體大小並不重要, 需要的則是一種方法, 通知編譯器在哪一位址存放哪些資料.</p>
<p>這樣的變數稱為"指標變數" (隨後將說明得更清楚). 在 C 語言中定義指標變數時, 必須在變數名稱前方, 加上一個 * 符號. 而這些指標變數的型別, 隨著要存放在指標位址中的資料型別而定, 例如, 假如宣告:</p>
<p>int *ptr;</p>
<p>ptr 為變數名稱 (與之前的整數變數名稱 k 相同). 而 "*" 符號則告知編譯器, 此一宣告為指標變數, 亦即保留出足夠的記憶體存放位址. 最前方的 int 則表示, 希望此一指標變數用來存放整數. 而此一指標稱為"指向整數". 需要特別注意的是, 當使用 int k; 時並沒有給 k 初始值, 只有在任何符合 ANSI 規範的編譯器中, 會將宣告在函式外的變數通通以 0 初始.</p>
<p>同樣地, ptr 也沒有初始值, 亦即, 還沒有在上述宣告之後, 在保留的位址空間上, 放入任何值. 這裡若宣告是在任何函式之外, 就會被賦予初值, 並且保證不會指向任何 C 物件或函式. 以這種方式初始的指標, 被稱為 "空"指標 (null pointer).</p>
<p>而空指標並不一定會被放入 "0" 值, 因為這取決於特定系統中的設定. 為了在不同系統中的不同編譯器彼此相容, 就會利用巨集 (macro) 來表示空指標. 此巨集以 NULL 命名. 因此, 若以 NULL 設定指標值, 則可以確定在不同機器上, 這些指標變數一定是空指標.</p>
<p>與整數是否為 0 的判斷式 if(k ==0) 相類似, 可以利用 if(ptr == NULL) 判斷是否 ptr 為空指標.</p>
<p>但是, 回到新變數 ptr 的應用, 假設要將整數變數 k 所對應的位址, 存入 ptr, 就必須使用"位址運算子", 寫成:</p>
<p>ptr = &amp;k;</p>
<p>"位址運算子"的作用是用來取 k 的左值 (位址), 即使這時 k 位於等號右邊, 上述程式會將 k 的值複製到指標 ptr 的儲存空間中. 這時, ptr 稱為"指向" k.</p>
<p>接著再討論另外一個運算子.</p>
<p>也就是所謂的"取值運算子" (dereferencing operator), 就是一個 * 符號. 使用方法如下:</p>
<pre>*ptr = 7;</pre>
<p>這行程式會將 7 這個數值,複製到 ptr 變數所指向的位址. 也就是說, 假如 ptr 指向 k (ptr 為 k 存放資料的記憶體位址), 這行程式就會將 k 的值設為 7. 換言之, * 運算子可用來改變 ptr 所指向的值, 而不是指標本身的值. (註:指標本身為位址, 也就是所謂的左變數)</p>
<p>因此, 可以利用:</p>
<p>printf("%d\n",*ptr);</p>
<p>將目前存放在 ptr 所指向位址的整數值, 給印到螢幕.</p>
<p>要釐清上述說明, 可以執行下列程式, 並仔細探討程式碼與其輸出.</p>
<p><span>------------ Program 1.1 ---------------------------------</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">/* Program 1.1 from PTRTUT10.TXT   6/10/97 */
 
#include &lt;stdio.h&gt;
 
int j, k;
int *ptr;
 
int main(void)
{
    j = 1;
    k = 2;
    ptr = &amp;k;
    printf("\n");
    printf("j has the value %d and is stored at %p\n", j, (void *)&amp;j);
    printf("k has the value %d and is stored at %p\n", k, (void *)&amp;k);
    printf("ptr has the value %p and is stored at %p\n", ptr, (void *)&amp;ptr);
    printf("The value of the integer pointed to by ptr is %d\n", *ptr);
 
    return 0;
}</pre>
<p><a href="http://codepad.org/w8R9mp9h">在 codepad.org 執行 Program 1.1</a></p>
<p>請注意: 我們還沒有談到 C 程式中的 (void *) 表示式. 這裡可以先納入您的測試程式碼中, 隨後將會加以說明.</p>
<p>結論:</p>
<p>變數宣告必須指定名稱與型別<span class="o">.</span> <span class="o">(</span><span class="nt">例如</span><span class="o">:</span> <span class="nt">int</span> <span class="nt">k</span><span class="o">;)</span> <span class="nt">2</span><span class="o">.</span> <span class="nt">指標變數宣告也是指定名稱與型別</span><span class="o">.</span> <span class="o">(</span><span class="nt">例如</span><span class="o">:</span> <span class="nt">int</span> <span class="o">*</span><span class="nt">ptr</span><span class="o">;),</span> <span class="nt">其中的</span> <span class="o">*</span> <span class="nt">告知編譯器</span><span class="o">,</span> <span class="nt">該名稱為</span> <span class="nt">ptr</span> <span class="nt">的變數</span><span class="o">,</span> <span class="nt">為一個指標變數</span><span class="o">,</span> <span class="nt">而其型別為該指標指向的資料型別</span> <span class="o">(</span><span class="nt">這裡為整數</span><span class="o">).</span> <span class="nt">3</span><span class="o">.</span> <span class="nt">一旦變數已經宣告</span><span class="o">,</span> <span class="nt">可以透過變數前方的位址運算子</span><span class="o">,</span> <span class="nt">取得其位址</span><span class="o">,</span> <span class="nt">例如</span> <span class="o">&amp;</span><span class="nt">k</span><span class="o">.</span> <span class="nt">4</span><span class="o">.</span> <span class="nt">可以由指標中</span><span class="s2">"取值"</span><span class="o">,</span> <span class="nt">亦即</span><span class="o">,</span> <span class="nt">以</span> <span class="o">*</span> <span class="nt">指定到指標所參照的值</span><span class="o">,</span> <span class="nt">例如</span><span class="o">:</span> <span class="o">*</span><span class="nt">ptr</span><span class="o">.</span> <span class="nt">5</span><span class="o">.</span> <span class="nt">變數的左值為被用來存放在記憶體中的位址值</span><span class="o">,</span> <span class="nt">而變數的右值則式被存放在該位址的數值</span><span class="o">.<br><br></span></p>
<p>參考資料:</p>
<p>"The C Programming Language" 2nd Edition B. Kernighan and D. Ritchie Prentice Hall ISBN 0-13-110362-8</p>
<p>第二章: 指標型別與陣列</p>
<p>接著讓我們來看看, 為何需要指定指標指向變數的型別, 例如: int *ptr; 原因之一是, 宣告之後, 可以透過指向, 寫成:</p>
<p>*ptr = 2;</p>
<p>編譯器就會知道要配置多少記憶體給 ptr 變數, 假如 ptr 宣告為指向整數, 電腦就會複製 4 位元的資料, 其它的浮點與雙浮點變數也是相同. 定義指向變數型別的另外一個用途就是編譯器可以解譯程式碼. 例如, 記憶區中存放 10 個連續的整數資料時, 需要 40 位元的記憶體.</p>
<p>假如整數指標 ptr 為這些整數中的第一個變數, 若該整數位於記憶體位址 100. 當程式寫為:</p>
<p>ptr + 1;</p>
<p>因為編譯器知道 ptr 為一個指標變數 (亦即, 其值為一組位址)並且指向某一整數 (目前位址為 100, 即是該整數所在位址), 當 ptr 加上 4 而不是 1 之後, 該指標將會指向下一個整數, 也就是記憶體 104.</p>
<p>相同的概念下, 若 ptr 指向短整數, 則應該加上 2 而不是 1. 對於浮點, 雙浮點或使用者自訂的資料型別 - 結構, 也是類似.</p>
<p>儘管這並非我們常見的"加法", 但是在 C 語言中, 可以透過指標算數進行"加法"運算, 隨後將會再予以說明.</p>
<p>同理, 因為 ++ptr 與 ptr++ 與 ptr + 1 等同 (儘管 ptr 增量的時機點並不一樣).</p>
<p>讓指標以 ++ 增量運算子進行增量, 無論是先加或後加, 由 sizeof(type) 中所得到的位址增量, 其型別均為該物件指向變數的型別 (整數為 4 位元).</p>
<p>由於這 10 個整數位於記憶體中連續區塊上, 指標可以被用於整數資料陣列的處理.</p>
<p>例如:</p>
<p>int my_array[] = {1,23,17,4,-5,100};</p>
<p>陣列中帶有 6 個整數. 可以透過 my_array 的索引代表這些整數. 亦即利用 my_array[0] 到 my_array[5] 加以表示, 也可以透過指標加以表示成:</p>
<p>int *ptr;<br>ptr = &amp;my_array[0]; /* 將指標指向陣列中的第一個整數*/</p>
<p>接著就可以使用陣列索引或取值運算, 列出陣列.</p>
<p>下列程式可以用來展示此一應用:</p>
<p>----------- Program 2.1 -----------------------------------</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">/* Program 2.1 from PTRTUT10.HTM   6/13/97 */
 
#include &lt;stdio.h&gt;
 
int my_array[] = {1,23,17,4,-5,100};
int *ptr;
 
int main(void)
{
    int i;
    ptr = &amp;my_array[0];     /* point our pointer to the first
                                      element of the array */
    printf("\n\n");
    for (i = 0; i &lt; 6; i++)
    {
      printf("my_array[%d] = %d   ",i,my_array[i]);   /*&lt;-- A */
      printf("ptr + %d = %d\n",i, *(ptr + i));        /*&lt;-- B */
    }
    return 0;
}</pre>
<p><a href="http://codepad.org/3fgCKs7N">在 codepad.org 執行 Program 2.1</a></p>
<p>編譯執行上列程式就可以仔細觀察 A 行與 B 行程式分別採用兩種方法列出陣列中的同一內容.</p>
<p>也可以清楚看到 B 行程式如何應用"取值"運算, 亦即, 首先在指標增量後, 在新的指標中取值. 將 B 行程式改為</p>
<p>printf("ptr + %d = %d\n",i, *ptr++);</p>
<p>之後再執行, 接著改為:</p>
<p>printf("ptr + %d = %d\n",i, *(++ptr));</p>
<p>再執行, 執行之前先判定結果, 並與實際執行結果進行比較.</p>
<p>在 C 語言, 可以利用 var_name 來替代 &amp;var_name[0], 因此在程式碼中寫成:</p>
<div class="codehilite">
<pre>ptr = &amp;my_array[0];
<br><span>或:</span><br><br></pre>
<pre>ptr = my_array;</pre>
<p>都會得到相同的結果.</p>
<p>因此許多參考書都寫道: 陣列的變數名稱就是指標. 但是比較好的想法則是: 陣列的變數名稱就是陣列中第一元件的位址. 許多初學者 (包含作者本人), 都會將其視為指標.</p>
<p>但是, 可以寫成:</p>
<p>ptr = my_array;</p>
<p>但是卻不能寫成:</p>
<p>my_array = ptr;</p>
<p>原因就是 ptr 為變數, 但是 my_array 卻是常數, 也就是說, my_array 第一元件的位址, 一旦在 my_array[] 完成宣告後, 就不可以改變.</p>
<p>先前曾討論的左值, 中引用 K&amp;R-2 中所言:</p>
<p>"物件為儲存區域的名稱, 而左值則為指向該物件的表示式."</p>
<p>這就衍生出一個有趣的議題. 因為 my_array 為儲存區域的代表名稱, 為何 my_array 在上面的指定敘述程式中, 卻不能用在左值區域?</p>
<p>為了說明這點, 可以將 my_array 視為"不可改變的左值".</p>
<p>上列範例可以將:</p>
<pre>ptr = &amp;my_array[0];<br><br><span>改為:</span><br><br></pre>
<pre>ptr = my_array;<br><br></pre>
<p>確認兩者會得到相同的結果.</p>
<p>至於 ptr 與 my_array 之間的差異, 有人將陣列變數名稱視為"常數指標". 為了充分了解所謂"常數"的真諦, 重回變數定義時的說明.</p>
<p>當變數宣告時, 用來存值的記憶體就必須加以配置. 這時變數可以透過兩個層面來看.</p>
<p>用在指定運算左邊時, 編譯器會視其為記憶位址, 用來指向右側所設定的值.</p>
<p>若被用在運算右邊時, 變數名稱會被解讀為存在該記憶體中的值.</p>
<p>有了以上的概念, 關注簡單的常數運算:</p>
<pre>int i, k;
i = 2;<br><br></pre>
<p>其中 i 為存放 2 常數的變數, 並非直接在資料記憶區塊中指定, 而是直接存入程式記憶區塊.</p>
<p>當 k = i; 程式碼就會到 &amp;i 位址中抓取要複製到 k 的值, 而 i = 2; 只是將 2 放入程式碼, 而沒有取值的運作. 也就是說, k 與 i 都是物件, 但是 2 則非物件.</p>
<p>同理, 由於 my_array 為常數 (為位址值), 一旦編譯器設好用來存值得區域後, my_array[0] 存值得記憶體位址就已經確定, 因此可以使用:</p>
<pre>ptr = my_array;<br><br>將此在程式區段中的常數位址設給 ptr, 其中並沒有牽涉到資料區段的取值操作.</pre>
<p>這時就可進一步說明第一章程式 1.1. 中 (void *) 的應用. 由於指標可被用來指向各種資料型別. 除了可以指向整數, 也可以指向字元, 之後還會介紹指向結構與指向指標的指標變數.</p>
<p>由於在不同系統中的指標儲值大小會有差別, 並且指標的記憶體空間會隨著指向物件資料型別差異而有所不同.</p>
<p>因此若將長整數指給短整數資料型別變數時, 就會發生問題, 也可以將某一型別的指標變數指定給其他不同型別指標變數時, 產生問題.</p>
<p>為了克服此一問題, C 語言提供 void 這個空的指標資料型別.</p>
<p>假如將某一指標設定為:</p>
<p>void *vptr;</p>
<p>空指標可以視為通用指標. 由於 C 語言不允許整數型別指標與字元型別指標之間的資料交換或比較. 這時就可以透過空指標作為中介, 在特殊情況下在指標型別間進行資料轉換.</p>
<p>在第一章的 1.1 程式中, 就是使用空指標將整數指標轉成能與 %p 資料相符的格式.</p>
<p>下列各章, 也將透過此一概念進行資料轉換.</p>
<p>這裡列出許多技術資料給初學者, 首次閱讀時或許不很容易理解. 因此需要前後執行幾次程式, 看看結果, 並且仔細查驗這兩個例子中的程式碼與產出結果, 才會有所突破.</p>
<p>接下來, 將討論指標, 字元陣列與字串間的關係.</p>
</div>
<pre><span class="o"></span></pre><h1>工具</h1>
<p>USB 可攜程式開發系統</p>
<p>可解譯 ANSI C</p>
<p>可解譯 Python</p>
<p>可解譯 Lua</p>
<h2>Git</h2>
<p><a href="https://git-scm.com/">https://git-scm.com/</a>&nbsp;</p>
<p><a href="https://git-scm.com/book/zh-tw/v2">https://git-scm.com/book/zh-tw/v2</a>&nbsp;</p>
<p><a href="https://github.com/">https://github.com/</a>&nbsp;</p>
<p><a href="http://www.globallegalchronicle.com/microsofts-7-5-billion-acquisition-of-github/">http://www.globallegalchronicle.com/microsofts-7-5-billion-acquisition-of-github/</a>&nbsp;</p>
<p>git 常用指令</p>
<p>git add .</p>
<p>新增所有改版內容</p>
<p>git commit -m "提交訊息, 用來辨識版本"</p>
<p>在近端提交改版內容</p>
<p>git push</p>
<p>將近端改版內容推送到遠端</p>
<p>git pull</p>
<p>拉下遠端新版本內容, 在 fossil scm 使用 fossil update</p>
<p>git log</p>
<p>查驗 git 提交推送紀錄</p>
<p>git status</p>
<p>查驗狀態</p>
<p>git 新增提交推送的身分綁定</p>
<p>以 scrum1@mde.tw 註冊帳號為 scrum-1 為例:</p>
<p>git config --global user.name "scrum-1"</p>
<p>git config --global user.email "scrum1@mde.tw"</p>
<p>若網路直接連線過慢, 可以透過 proxy 執行 git</p>
<p>git config --global http.proxy http://proxy.kmol.info:3128</p>
<p>以上的 git config 會將設定存入 Y:/home/.gitconfig 檔案中</p>
<p>刪除近端與遠端的 Git 分支.</p>
<p>To delete a local branch</p>
<p>git branch -D the_local_branch</p>
<p>To remove a remote branch</p>
<p>git push origin :the_remote_branch</p>
<p>or</p>
<p>git push origin --delete the_remote_branch</p>
<h2>Fossil SCM</h2>
<p><a href="https://www.fossil-scm.org">https://www.fossil-scm.org</a>&nbsp;</p>
<p>Fossil SCM 是一套簡潔可靠的分散式組態管理工具, 內建網際介面, 臭蟲追蹤, 快記與技術筆記功能的單一可執行檔.</p>
<p>Fossil SCM 為自由開放源軟體, 使用者可以自行在 Windows 或 Linux 環境中編譯. 例如: 在 Windows 環境, 以 <a href="https://www.msys2.org/">MSYS2</a> 編譯:&nbsp;<a href="http://lab.kmol.info/blog/msys2_compile_fossil_scm.html">http://lab.kmol.info/blog/msys2_compile_fossil_scm.html</a>&nbsp;</p>
<p>在 Windows 單機環境使用:</p>
<p>下載 fossil.exe:&nbsp;<a href="https://www.fossil-scm.org/index.html/uv/download.html">https://www.fossil-scm.org/index.html/uv/download.html</a>&nbsp;</p>
<p>解開壓縮檔案後, 可以直接在 Windows 命令列中執行 fossil.exe</p>
<p>目前 Fossil SCM 最新版為 2.6, 若配合遠端 Ubuntu 伺服器使用,&nbsp; 必須確認客戶端與伺服器端的 fossil 版本一致, 否則將可能造成使用上的問題.</p>
<p>查核 fossil.exe 版本:</p>
<p>fossil version</p>
<p>利用 fossil help 可以列出常用指令.</p>
<p>Fossil SCM 單機基本操作:</p>
<p>建立倉儲檔案</p>
<p>fossil init foo.fossil</p>
<p>表示建立一個新的倉儲專案, 且倉儲檔案名稱為 foo.fossil, 在 fossil SCM 中建立新專案時, 登入用戶名稱會成為內定的倉儲管理者, 若要指定管理者名稱, 可以附加 -A USERNAME 或 --admin-user USERNAME, 新增的倉儲就會以 USERNAME 作為管理者名稱, 且指定對應的密碼 (有關<span>&nbsp;</span><a href="http://fossil-scm.org/xfer/doc/trunk/www/password.wiki">fossil 密碼管理</a>), 當使用者在近端以網際模式啟動該倉儲時 (以<span>&nbsp;</span><a href="http://fossil-scm.org/index.html/help?cmd=ui">fossil ui</a><span>&nbsp;</span>指令) fossil SCM 會直接以管理者身份登入, 無需輸入管理者密碼.</p>
<p>以 fossil sql 指令擷取 .fossil 檔案內容</p>
<p>使用者以 fossil init foo.fossil 建立倉儲檔案後, 可以利用 fossil 指令查驗倉儲資料庫檔案的內容.</p>
<p>fossil sql -R foo.fossil</p>
<p>進入 sqlite 指令環境後, 可以利用 .schema user 查驗 user 資料表的欄位設計.</p>
<p>以 select login, pw, cap from user;</p>
<p>可以查詢目前 foo.fossil 檔案中 user 資料表 login, pw 與 cap 等3個欄位的資料內容.</p>
<p>若要更改特定 login 登入帳號的 pw 或 cap 可以使用下列 sqlite3 SQL 語法:</p>
<p>update user set pw='mynewpassword' where login='myloginaccount';</p>
<p>update user set cap='s' where login='myloginaccount';</p>
<p>倉儲&nbsp; clone</p>
<div class="line number1 index0 alt2"><code class="jscript plain">$ fossil clone http:</code><code class="jscript comments">//your_domain_name ~/fossils/yourdb.fossil</code></div>
<div class="line number2 index1 alt1"><code class="jscript plain">$ fossil open ~/fossils/foo.fossil</code></div>
<div>
<div id="highlighter_133709" class="syntaxhighlighter  jscript"></div>
</div>
<p>上述 fossil 指令表示要從 http://your_domain_name fossil 伺服器中, clone 倉儲檔案, 然後存在近端的 ~/fossils/yourdb.fossil 檔案中.</p>
<p>接下來則可以選擇適當的目錄, 以 fossil open 將 .fossil 檔案解開, 此所在目錄即為該 .fossil 倉儲的 近端工作目錄.</p>
<h2>Leo Editor</h2>
<p><a href="http://www.leoeditor.com/">http://www.leoeditor.com/</a>&nbsp;</p>
<h2>SCiTE</h2>
<p><a href="https://www.scintilla.org/SciTE.html">https://www.scintilla.org/SciTE.html</a>&nbsp;</p>
<p>利用 SciTE 執行 Pelican 網誌 Markdown 轉為 html:</p>
<p>SciTEUser.properties 設定</p>
<p>以下的設定, 是將近端與遠端<span>&nbsp;</span><a href="https://github.com/getpelican/pelican">Pelican</a><span>&nbsp;</span>轉檔指令, 設為 Pelican-blog 與 Github-blog 下拉式功能表, 位於 Tools-Go 下方, 唯一的限制是, 當執行這兩個指令時,<span>&nbsp;</span><a href="http://www.scintilla.org/SciTE.html">SciTE</a><span>&nbsp;</span>必須處於開啟 content 目錄之外的 local_publishconf.py 檔案, 因為<span>&nbsp;</span><a href="http://www.scintilla.org/SciTE.html">SciTE</a><span>&nbsp;</span>會以開啟檔案所在目錄, 執行所設定的<span>&nbsp;</span><a href="https://github.com/getpelican/pelican">Pelican</a><span>&nbsp;</span>指令.</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">import Properties\python
import _platform
import _config
 
#~ #  1142  Pelican-blog
command.name.42.*=Pelican-blog
command.42.*="pelican content -o blog -s local_publishconf.py"
#command.subsystem.42.*=2
#command.quiet.42.*=1
command.shortcut.42.*=Ctrl+Shift+P
 
#~ #  1143 Github-blog
command.name.43.*=Github-blog
command.43.*="pelican content -o blog -s publishconf.py"
#command.subsystem.42.*=2
#command.quiet.42.*=1
command.shortcut.43.*=Ctrl+Shift+G</pre>
<div></div>
<div>啟動 IPv4 或 IPv6 www 伺服器
<p>當<span>&nbsp;</span><a href="https://github.com/getpelican/pelican">Pelican</a><span>&nbsp;</span>轉檔指令執行結束後,<span>&nbsp;</span><a href="http://www.scintilla.org/SciTE.html">SciTE</a><span>&nbsp;</span>會在輸出區列出執行結束訊息, 若轉檔過程發生錯誤, 也會一併顯示. 之後為了檢視轉換完成的近端簡報或網誌檔案, 必須將原先位於<span>&nbsp;</span><a href="http://leoeditor.com/">Leo Editor</a><span>&nbsp;</span>button 區的按鈕 Python3 程式移出, 分別存為 .py 檔案.</p>
<p>由於原先的<span>&nbsp;</span><a href="http://leoeditor.com/">Leo Editor</a><span>&nbsp;</span>button 位於 users 目錄中執行, 因此轉出的 .py 檔案也存入 users 目錄中, 程式內容如下:</p>
<p>users/ipv4_www_server.py 程式檔</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">#ipv4_www_server.py 存入 users 目錄
import os
import subprocess
import threading
import http.server, ssl
 
def domake():
    # build directory
    os.chdir("./../")
    server_address = ('localhost', 5443)
    httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)
    httpd.socket = ssl.wrap_socket(httpd.socket,
                                   server_side=True,
                                   certfile='localhost.crt',
                                   keyfile='localhost.key',
                                   ssl_version=ssl.PROTOCOL_TLSv1)
    print(os.getcwd())
    print("5443 https server started")
    httpd.serve_forever()
 
# 利用執行緒執行 https 伺服器
make = threading.Thread(target=domake)
make.start()</pre>
<p><span>users/ipv6_www_server.py 程式檔</span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">#ipv6_www_server.py 存入 users 目錄
import os
import subprocess
import threading
import socket
import http.server, ssl
 
class HTTPServerV6(http.server.HTTPServer):
    address_family = socket.AF_INET6
 
def domake():
    # build directory
    os.chdir("./../")
    ipv6_address = '::1'
    server_address = (ipv6_address, 6443)
    #httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)
    httpd = HTTPServerV6(server_address, http.server.SimpleHTTPRequestHandler)
    httpd.socket = ssl.wrap_socket(httpd.socket,
                                   server_side=True,
                                   certfile='localhost.crt',
                                   keyfile='localhost.key',
                                   ssl_version=ssl.PROTOCOL_TLSv1)
    print("6443 https server started")
    httpd.serve_forever()
 
# 利用執行緒執行 https 伺服器
make = threading.Thread(target=domake)
make.start()</pre>
<p></p>
</div>
<h2>TinyCC</h2>
<p><a href="https://bellard.org/tcc/">https://bellard.org/tcc/</a>&nbsp;</p>
<p><a href="https://github.com/jerch/python-tinycc">https://github.com/jerch/python-tinycc</a>&nbsp;</p>
<p><a href="https://github.com/SasView/tinycc">https://github.com/SasView/tinycc</a>&nbsp;</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">#include &lt;stdio.h&gt;

/* a struct with some bytes and a length */
typedef struct Test {
    int length;
    unsigned char *bytes;
} Test;

/* some globals */

#ifdef STANDALONE
Test test = {10, "standalone"};
#else
Test test = {26, "abcdefghijklmnopqrstuvwxyz"};
#endif

int value = 12345;

int main(int argc, char **argv) {
    int i;
    char **pos = argv;

    printf("Hello Tiny C!\n");

    /* list arguments */
    for (i=0; i&lt;argc; ++i, ++pos) {
        printf("arg %d: %s\n", i, *pos);
    }

    /* byte printing the hard way ;) */
    printf("test.value: '");
    for (i=0; i&lt;test.length; ++i)
        printf("%c", *(test.bytes+i));
    printf("'");


    if (*test.bytes == 'a')
        printf(" - not so impressive.\n");
    else if (*test.bytes == 's')
        printf(" - ok.\n");
    else
        printf(" - Busted!\n");
    return 0;
}</pre>
<p>利用 Tiny C 編譯 Tiny C</p>
<p>利用 Tiny C compiler 編譯 Windows 10 64 位元 dll 動態連結庫, 並由 Python 程式呼叫執行.</p>
<p><span>從&nbsp;</span><a href="http://download.savannah.gnu.org/releases/tinycc/">http://download.savannah.gnu.org/releases/tinycc/</a><span>&nbsp;</span><a href="http://download.savannah.gnu.org/releases/tinycc/tcc-0.9.27-win64-bin.zip">下載</a><span>&nbsp;Win64 C 程式編譯器, 並</span><a href="http://download.savannah.gnu.org/releases/tinycc/tcc-0.9.27.tar.bz2">下載</a><span>&nbsp;Tiny C compiler 0.9.27版程式原始碼. 利用下列批次檔案進行編譯.</span></p>
<p><span>compile.bat 檔案內容:</span></p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">echo Use TCC to compile TCC

set /p VERSION= &lt; VERSION
echo &gt; config.h #define TCC_VERSION "%VERSION%"

 
echo Set CC=tcc
 
set CC=tcc
set target=-DTCC_TARGET_PE -DTCC_TARGET_X86_64
set P=64
 
echo tools: tiny_impdef.exe, tiny_libmaker.exe
 
%CC% %target% win32/tools/tiny_impdef.c -o tiny_impdef.exe
%CC% %target% win32/tools/tiny_libmaker.c -o tiny_libmaker.exe
 
echo Compile libtcc.dll
 
if not exist libtcc\nul mkdir libtcc
%CC% %target% -w -shared -DLIBTCC_AS_DLL -DONE_SOURCE libtcc.c -o libtcc.dll
tiny_impdef libtcc.dll -o libtcc/libtcc.def
 
echo Compile tcc.exe
 
%CC% %target% tcc.c -o tcc.exe -ltcc -Llibtcc
 
echo Compile libcc1.a
 
%CC% %target% -c lib/libtcc1.c
%CC% %target% -c win32/lib/crt1.c
%CC% %target% -c win32/lib/wincrt1.c
%CC% %target% -c win32/lib/dllcrt1.c
%CC% %target% -c win32/lib/dllmain.c
%CC% %target% -c win32/lib/chkstk.S
%CC% %target% -c lib/alloca86_64.S
tiny_libmaker lib/libtcc1.a libtcc1.o alloca86_64.o crt1.o wincrt1.o dllcrt1.o dllmain.o chkstk.o</pre>
<p>編譯 dll 動態程式庫</p>
<p><span>首先, 建立一個 multiply.c 程式:</span></p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">#include &lt;stdio.h&gt;
 
int multiply(int, int);
 
__declspec(dllexport) int
multiply(int num1, int num2)
{
return num1 * num2;
}</pre>
<p>利用下列指令, 將 multiply.c 編譯為動態連結庫 myltiply.dll</p>
<p>tcc -w -shared -DLIBTCC_AS_DLL -DONE_SOURCE multiply.c -o multiply.dll</p>
<p>接著利用下列 Python3 程式, 透過 ctypes 模組導入 multiply.dll, 並且執行動態連結程式庫中的 multiply() 函式.</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import ctypes
 
lib = ctypes.CDLL('multiply.dll')
result = lib.multiply(3, 2)
print(result)</pre>
<p>因為<span>&nbsp;</span><a href="https://docs.python.org/3/library/ctypes.html">ctypes</a><span>&nbsp;</span>內建傳回值為 int, 因此若 C 對應動態連結庫輸入或傳回值為浮點數, 就必須手動宣告.</p>
<p>例如, 將上述函式的輸入與輸出均由 int 改為 float 如下:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">// multiply2.c
#include &lt;stdio.h&gt;
 
float multiply(float, float);
 
__declspec(dllexport) float
multiply(float num1, float num2)
{
return num1 * num2;
}</pre>
<p>可利用下列指令, 將 multiply2.c 編譯為動態連結庫 myltiply2.dll</p>
<p>tcc -w -shared -DLIBTCC_AS_DLL -DONE_SOURCE multiply2.c -o multiply2.dll</p>
<p>但是 Python3 程式部份就必須改為:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import ctypes
 
lib = ctypes.CDLL('multiply2.dll')
# By default functions are assumed to return the C int type. Other return types can be specified by setting the restype attribute of the function object.
lib.multiply.restype = ctypes.c_float
result = lib.multiply(ctypes.c_float(3.0), ctypes.c_float(2.0))
print(result)</pre>
<p>有關 Tiny C Compiler 資料位於&nbsp;<a href="https://github.com/mdecourse/cp2018/tree/gh-pages/tinyc">https://github.com/mdecourse/cp2018/tree/gh-pages/tinyc</a>&nbsp;</p>
<p></p>
<h2>CMSimfly</h2>
<p><a href="https://github.com/chiamingyen/cmsimfly">https://github.com/chiamingyen/cmsimfly</a></p>
<h1>應用範例</h1>
<p>學習計算機程式的目的在利用數位科技技術解決問題, 所謂數位科技技術包括程式套件、網路與資料庫等元件的組合.</p>
<p>基本流程為:</p>
<ol>
<li>如何取得、傳輸並處理資料?</li>
<li>如何儲存資料?</li>
<li>如何呈現資料?</li>
</ol>
<p>處理資料的過程依賴數學模型、演算法與資料結構</p>
<p>取得與傳輸資料則依賴網路</p>
<p>至於資料的呈現則涵蓋 2D/3D 動態與靜態格式處理</p>
<ol>
<li>Tinkercad Circuit - Arduino 控制卡與電子致動與感測元件線路的模擬</li>
<li>網頁資料解讀與任務派送 - 計算機程式對特定格式資料的分析後, 依照循環與亂數流程進行分配</li>
<li>V-rep - 利用各種程式介面與延伸程式的設計, 讓使用者設計、控制並模擬各種機器人模型</li>
<li>輔助設計套件 - 利用計算機圖學與視窗介面, 讓使用者完成設想中的機械零組件設計, 並進行功能模擬</li>
</ol>
<h2>計算器</h2>
<p>PyQt5 計算機程式說明</p>
<p>按鍵分類</p>
<ul>
<li>0 ~9 數字按建, 點按後由 digitClicked() 方法槽承接處理</li>
<li>直接運算元, 包括 Sqrt, x^2 與 1/x, 點按後由 unaryOperatorClicked() 方法槽承接處理</li>
<li>加或減運算元, 包括 + 與 - 運算, 點按後由 additiveOperatorClicked() 方法槽承接處理</li>
<li>乘或除運算元, 包括 * 與 / 運算, 點按後由 multiplicativeOperatorClicked() 方法槽承接處理</li>
<li>其餘按鍵則各自以特定的方法槽承接處理</li>
</ul>
<p>變數與運算流程考量</p>
<ul>
<li>數字按鍵以 zero, one, two, three, four, five, six, seven, eight, nine 命名</li>
<li>顯示幕以 display 命名</li>
<li>等號以 equalButton 命名</li>
<li>與 MS, M+, 或 MC 按鍵相關的計算機記憶體數值, 存入 sumInMemory 變數對應的記憶空間</li>
<li>以 sumSoFar 儲存累計數值, 使用者按下等號後, sumSoFar 重新計算結果, 並顯示在 display 幕, Clear All 按鍵則重置 sumSoFar 為 0</li>
<li>以 factorSoFar 儲存乘或除運算子運算過程所得的暫存數值</li>
<li>以 pendingAdditiveOperator 儲存使用者最後點按的加或減運算子字串</li>
<li>以 pendingMultiplicativeOperator 儲存使用者最後點按的乘或除運算子字串</li>
<li>以 waitingForOperand 界定使用者是否處理運算數輸入階段, 若 waitingForOperand 為 True, 表示計算機正在等待使用者"開始"輸入運算數</li>
<li>waitingForOperand 起始值為 True, 只有重新進入 digitClicked 方法, display 才會 clear(), 否則在顯示幕非為 0 的情況下, 將堆疊數字字串</li>
<li>因為考量先乘除後加減運算順序, 將加減與乘除處理方法分開, 若使用者輸入加減運算子後, 緊接乘除運算子, 計算機會先乘除運算後再加減</li>
<li>直接運算元可以在使用者按下按鍵後, 直接對 display 中的數值進行處理, 無需其他暫存需求</li>
<li>pendingAdditiveOperator, pendingMultiplicativeOperator, sumSoFar, factorSoFar 與 waitingForOperand, 在 Dialog 類別建構子中設定起始值</li>
</ul>
<p>數字按鍵點按處理</p>
<ul>
<li>使用者點按數字按鍵, 將會送出該按鍵的 clicked() 訊號</li>
<li>按鍵的 clicked() 訊號將會根據設定, 觸發 digitClicked() 方法槽</li>
<li>由於 PyQt5 的 Push Button 以 Qt5 中的 QObject::sender() 送出訊號, 此函式會傳回 sender 作為 QObject 的指標</li>
<li>因為此一與 Push Button 配合的 sender 為 Button 物件, 因此可以在 digitClicked() 函式中, 利用 sender().text() 取得按鍵的 text 字串</li>
<li>假如使用者點按 0, display 顯示字串 0, 但是若一開始輸入兩個以上的 0, digitClicked() 應該仍只顯示 0 字串</li>
<li>但是若計算機處於等待新運算數輸入時 (以 waitingForOperand 判定), 新數字在顯示前, display 應該要清除先前所顯示的數字</li>
<li>最後, 除了在顯示幕為 0 之後的 0 按鍵輸入, digitClicked() 方法槽不會繼續判定是否清除顯示幕或堆疊數字字串外, 所按的數字將會堆疊顯示</li>
</ul>
<p>直接運算按鍵處理</p>
<ul>
<li>Sqrt, x^2 與 1/x 等按鍵的處理方法為 unaryOperatorClicked(), 與數字按鍵的點按回應相同, 透過 sender().text() 取得按鍵上的 text 字串</li>
<li>unaryOperatorClicked() 方法隨後根據 text 判定運算子後, 利用 display 上的運算數進行運算後, 再將結果顯示在 display 顯示幕</li>
<li>若進行運算 Sqrt 求數值的平方根時, 顯示幕中為負值, 或 1/x 運算時, x 為 0, 都視為無法處理的情況, 以呼叫 abortOperation() 處理</li>
<li>abortOperation() 方法則重置所有起始變數, 並在 display 中顯示 "####"</li>
<li>直接運算子處理結束前, 運算結果會顯示在 display 中, 而且運算至此告一段落, 計算機狀態應該要回復到等待新運算數的階段, 因此 waitingForOperand 要重置為 True</li>
</ul>
<p>加或減按鍵處理</p>
<ul>
<li>使用者按下加或減運算子按鍵時, 程式設定以 additiveOperatorClicked() 處理</li>
<li>進入 additiveOperatorClicked() 後, 必須先查是否有尚未運算的乘或除運算子, 因為必須先乘除後才能加減</li>
<li>先處理乘與除運算後, 再處理加或減運算後, 將 sumSoFar 顯示在 display 後, 必須重置 sumSoFar 為 0, 表示運算告一段落</li>
</ul>
<p>乘或除按鍵處理</p>
<ul>
<li>使用者按下乘或除運算子按鍵時, 程式設定以 multiplicativeOperatorClicked() 處理</li>
<li>進入 multiplicativeOperatorClicked() 後, 無需檢查是否有尚未運算的加或減運算子, 因為乘除運算有優先權</li>
<li>先處理乘與除運算後, 再處理加或減運算, 將 sumSoFar 顯示在 display 後, 必須重置 sumSoFar 為 0, 表示運算告一段落</li>
</ul>
<p>小數點按鍵處理</p>
<ul>
<li>使用者按下小數點按鍵後, 以 pointClicked() 方法處理, 直接在 display 字串中加上 "." 字串</li>
</ul>
<p>數值變號按鍵處理</p>
<ul>
<li>使用者按下變號按鍵後, 由 changeSignClicked() 處理, 若顯示幕上為正值, 則在 display 字串最前面, 疊上 "-" 字串</li>
<li>假如顯示幕上為負值, 則設法移除 display 上字串最前方的 "-" 字元</li>
</ul>
<p>退格按鍵處理</p>
<ul>
<li>使用者按下退格按鍵後, 由 backspaceClicked() 處理, 這時可以利用 Python 字串數列中的 [:-1], 保留除了最後一個字元的字串</li>
<li>離開 backspaceClicked() 前 ,將顯示幕中原有字串的 [:-1] 字串, 顯示在 display 上</li>
<li>若退格後 display 上為空字串, 則顯示 0, 並且將 waitingForOperand 起始設為 True, 表示等待新運算數中</li>
</ul>
<p>清除按鍵處理</p>
<ul>
<li>使用者按下 Clear 按鍵後, 以 clear() 方法處理, 進入函式後, 將現有的運算數重置為 0</li>
<li>離開 clear() 前, 將 waitingForOperand 起始設為 True, 表示等待新運算數中</li>
<li>ClearAll 按鍵, 則將所有變數全部重置為起始狀態</li>
</ul>
<p>記憶體按鍵處理</p>
<ul>
<li>clearMemory() 方法與 "MC" 按鍵對應, 清除記憶體中所存 sumInMemory 設為 0</li>
<li>readMemory() 方法與 "MR" 按鍵對應, 功能為讀取記憶體中的數值, 因此將 sumInMemory 顯示在 display, 作為運算數</li>
<li>setMemory() 方法則與 "MS" 按鍵對應, 功能為設定記憶體中的數值，因此取 display 中的數字, 存入 sumInMemory</li>
<li>addToMemory() 方法與 "M+" 按鍵對應, 功能為加上記憶體中的數值, 因此將 sumInMemory 加上 display 中的數值</li>
<li>因為 setMemory() 與 addToMemory() 方法, 都需要取用 display 上的數值, 因此必須先呼叫 equalClicked(), 以更新 sumSoFar 與 display 上的數值</li>
</ul>
<p>calculate() 方法</p>
<ul>
<li>calculate() 方法中的運算, 以 rightOperand 為右運算數</li>
<li>當執行加或減運算時, 左運算數為 sumSoFar</li>
<li>當執行乘或除運算時, 左運算數為 factorSoFar</li>
<li>若運算過程出現除與 0 時, 將會回傳 False</li>
</ul>
<p><img src="/images/calculator_button_types.png" width="500" height="346" alt=""></p>
<p>Qt5 -<span>&nbsp;</span><a href="http://doc.qt.io/qt-5/qobject.html#sender">sender()</a></p>
<p>sip -<span>&nbsp;</span><a href="https://github.com/kmolab/web_repository/blob/master/PyQt5_gpl-5.9.2/sip/QtCore/qobject.sip">sip: sender()</a></p>
<p>PyQt5 計算機程式原始碼</p>
<p>Dialog.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># -*- coding: utf-8 -*-

"""
Module implementing Dialog.
"""

from PyQt5.QtCore import pyqtSlot
from PyQt5.QtWidgets import QDialog

from .Ui_Dialog import Ui_Dialog


# Dialog 類別同時繼承 QDialog 與 Ui_Dialog 類別
class Dialog(QDialog, Ui_Dialog):
    """
    Class documentation goes here. (若有類別相關說明文件內容, 放在此處)
    """
    def __init__(self, parent=None):
        """
        Constructor (類別建構子)
        
        @param parent reference to the parent widget
        @type QWidget
        """
        # 利用 super 類別調用 parent 類別中的建構子
        super(Dialog, self).__init__(parent)
        # 上一行在 Python3 可以寫為 super().__init__()
        # 利用 Ui_Dialog 類別中的 setupUi 方法, 以 self 視窗部件建立使用者介面
        self.setupUi(self)
        # 以上程式碼由 Eric6 表單頁面中的滑鼠右鍵, Generate Dialog Code 指令產生
        # 當多個 signal 同時指向同一個 slot 處理時, 採用 for loop
        num_button = [self.one,  self.two,  \
        self.three,  self.four,  self.five,  self.six,  self.seven,  self.eight,  self.nine,  self.zero]
        # 用於產生加號與減號 signals 與 slots 用的數列
        plus_minus = [self.plus,  self.minus]
        # 用於產生乘號與除號 signals 與 slots 用的數列
        multiply_divide = [self.multiply,  self.divide]
        #self.one.clicked.connect(self.number)
        # 數字按鍵的 signals 與 slots 設定
        for i in num_button:
            i.clicked.connect(self.number)
        
        # 加減鍵的 signals 與 slogts 設定
        for i in plus_minus:
            i.clicked.connect(self.additiveOperatorClicked)
        
        # 等於按鍵的 signal 與 slot 設定
        self.equal.clicked.connect(self.equalClicked)
        
        # 乘與除按建的 signals 與 slots 設定
        for i in multiply_divide:
            i.clicked.connect(self.multiplicativeOperatorClicked)
        
        # 等待運算的加或減
        self.pendingAdditiveOperator = ''
        
        # sumSoFar 儲存運算流程中所累計的數值
        # 當使用者按下 = 後, sumSoFar 重新計算並將數字顯示在 display 區
        # 當使用者按下 Clear All, sumSoFar 將重置回 0
        self.sumSoFar = 0.0
        # 起始時, 等待使用者輸入運算數值變數為真
        self.waitingForOperand = True
        
        # sumInMemory 儲存計算機記憶體中的值, 配合 MS, M+, 或 MC 按鈕使用
        self.sumInMemory = 0.0
        # factorSoFar 暫存按下乘或除運算時的數值
        self.factorSoFar = 0.0
        # 等待運算的乘或除
        self.pendingMultiplicativeOperator = ''

    def number(self):
        # sender() 為使用者點擊按鈕時送出的按鈕指標類別, 在此利用此按鍵類別建立案例
        # 所建立的 clickedButton 即為當下使用者所按下的按鈕物件
        clickedButton = self.sender()
        # text() 為利用按鈕物件的 text 方法取得該按鈕上所顯示的 text 字串
        digitValue = int(clickedButton.text())
        # when user clicks 0.0
        if self.display.text() == '0' and digitValue == 0.0:
            return
        
        # if under digit input process, clear display for the very first beginning
        # waitingForOperand 為 True 已經點按運算數值按鈕
        if self.waitingForOperand:
            # 清除 display 
            self.display.clear()
            # 將判斷是否已經點按運算數值按鈕的判斷變數重新設為  False
            self.waitingForOperand = False
        # 利用 setText() 設定 LineEdit 元件顯示字串, 利用 text() 取出目前所顯示的字串, 同時也可利用 text() 擷取按鈕物件上顯示的字串
        #self.display.setText(self.display.text() + self.sender().text())
        self.display.setText(self.display.text() + str(digitValue))
        
    def additiveOperatorClicked(self):
        # 確定按下加或減
        clickedButton = self.sender()
        # 確定運算子, 為加或減
        clickedOperator = clickedButton.text()
        # 點按運算子之前在 display 上的數字, 為運算數
        operand = float(self.display.text())
        
        # 納入乘與除之後的先乘除後加減運算邏輯, 且納入連續按下乘或除可累計運算
        if self.pendingMultiplicativeOperator:
            if not self.calculate(operand, self.pendingMultiplicativeOperator):
                self.abortOperation()
                return

            self.display.setText(str(self.factorSoFar))
            operand = self.factorSoFar
            self.factorSoFar = 0.0
            self.pendingMultiplicativeOperator = ''
            
            
        # 假如有等待運算的加或減, 進入執行運算
        # 且納入連續按下加或減時, 可以目前的運算數及運算子累計運算
        if self.pendingAdditiveOperator:
            if not self.calculate(operand, self.pendingAdditiveOperator):
                self.abortOperation()
                return
            # 顯示目前的運算結果
            self.display.setText(str(self.sumSoFar))
        else:
            # 假如 self.pendingAdditiveOperator 為 False, 則將運算數與 self.fumSoFar 對應
            self.sumSoFar = operand
            
        # 能夠重複按下加或減, 以目前的運算數值執行重複運算
        self.pendingAdditiveOperator = clickedOperator
        # 進入等待另外一個運算數值的階段, 設為 True 才會清空 LineEdit
        self.waitingForOperand = True

    # 處理使用者按下乘或除按鍵時的 slot 方法
    def multiplicativeOperatorClicked(self):
        clickedButton = self.sender()
        clickedOperator = clickedButton.text()
        # 將按鈕顯示的 text 轉為浮點數
        operand = float(self.display.text())

        # 若連續按下乘或除, 則以目前的運算數與運算子執行運算
        if self.pendingMultiplicativeOperator:
            if not self.calculate(operand, self.pendingMultiplicativeOperator):
                self.abortOperation()
                return

            # 將目前乘或除的累計運算數顯示在 display 上
            self.display.setText(str(self.factorSoFar))
        else:
            self.factorSoFar = operand

        # 能夠重複按下乘或除, 以目前的運算數值執行重複運算
        self.pendingMultiplicativeOperator = clickedOperator
        self.waitingForOperand = True
    
    def equalClicked(self):
        # 從 display 取的運算數值
        operand = float(self.display.text())
        
        # 先乘除的運算處理
        if self.pendingMultiplicativeOperator:
            if not self.calculate(operand, self.pendingMultiplicativeOperator):
                self.abortOperation()
                return
            # factorSoFar 為乘或除運算所得之暫存數值
            operand = self.factorSoFar
            self.factorSoFar = 0.0
            self.pendingMultiplicativeOperator = ''
        
        # 若有等待加或減的運算子, 執行運算
        if self.pendingAdditiveOperator:
            if not self.calculate(operand, self.pendingAdditiveOperator):
                self.abortOperation()
                return

            self.pendingAdditiveOperator = ''
        else:
            self.sumSoFar = operand

        self.display.setText(str(self.sumSoFar))
        self.sumSoFar = 0.0
        self.waitingForOperand = True

    # 右運算數與等待運算子當作輸入
    def calculate(self, rightOperand, pendingOperator):
        # 進入計算流程時, 用目前輸入的運算數值與 self.sumSoFar 執行計算
        if pendingOperator == "+":
            self.sumSoFar += rightOperand
        elif pendingOperator == "-":
            self.sumSoFar -= rightOperand

        elif pendingOperator == "*":
            self.factorSoFar *= rightOperand
        elif pendingOperator == "/":
            if rightOperand == 0.0:
                return False

            self.factorSoFar /= rightOperand

        return True</pre>
<p>run.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 導入 sys 模組, 主要用於 sys.argv 成員變數
import sys
# 從 PQt5 模組導入 QtWidgets 模組類別
from PyQt5 import QtWidgets
# 從 ui 目錄導入 Dialog.py, Python 程式檔案本身就是一個模組, 且文件名就是模組名
from ui import Dialog
 
# 每一個 Python 程式都可以直接被執行, 或者被導入其他程式中, 當成導入模組執行
# 假如程式檔案直接被執行時, 全域變數 __name__ 就會等於 "__main__" 字串
# 因此, 以下的判斷式的意思是, 若本檔案直接被執行時, 就會執行以下內縮程式區段
if __name__ == "__main__":
    # 利用 QtWidgets.QApplication 類別建立案例物件, 且以 sys.argv 作為輸入
    app = QtWidgets.QApplication(sys.argv)
    # 利用所導入的 Dialog 模組中的 Dialog 類別建立物件案例, 對應的變數名稱設為 win
    win = Dialog.Dialog()
    # 執行 win 物件中的 show() 方法, 因為所有 Qt5 部件內定為不顯示
    win.show()
    # 執行 app 物件的 exec() 方法, 表示進入視窗事件重複迴圈, 等待使用者滑鼠輸入
    # 將 app.exec() 當作 sys.exit() 執行輸入, 表示使用者可以透過視窗的 x 按鈕結束執行
    sys.exit(app.exec())</pre>
<p>上述完整的程式專案倉儲:&nbsp;<a href="https://github.com/kmolab/pymcadp/tree/gh-pages/2017fall">https://github.com/kmolab/pymcadp/tree/gh-pages/2017fall</a>&nbsp;</p>
<p><a href="http://lab.kmol.info/2017fall/blog/kmol-2017-fall-windows-calculator-development.html">視窗計算機程式開發</a></p>
<p><a href="https://mde1a1.kmol.info/2017fall/doc/trunk/blog/kmol-2017-fall-pyqt5-1.html">PyQt5 視窗程式一</a></p>
<p><a href="https://mde1a1.kmol.info/2017fall/doc/trunk/blog/kmol-2017-fall-pyqt5-2.html">PyQt5 視窗程式二</a></p>
<p><a href="https://mde1a1.kmol.info/2017fall/doc/trunk/blog/kmol-2017-fall-event-driven-programming-design.html">事件導向程式設計</a></p>
<p>完整的視窗計算器程式碼:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">#!/usr/bin/env python

import math

from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (QApplication, QGridLayout, QLayout, QLineEdit,
        QSizePolicy, QToolButton, QWidget)


class Button(QToolButton):
    '''
    def __init__(self, text, parent=None):
        super(Button, self).__init__(parent)
    '''
    # for Python 3
    def __init__(self, text):
        super().__init__()

        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        self.setText(text)

    def sizeHint(self):
        size = super(Button, self).sizeHint()
        size.setHeight(size.height() + 20)
        size.setWidth(max(size.width(), size.height()))
        return size


class Calculator(QWidget):
    NumDigitButtons = 10
    
    '''    
    def __init__(self, parent=None):
        super(Calculator, self).__init__(parent)
    '''
    def __init__(self):
        super().__init__()

        self.pendingAdditiveOperator = ''
        self.pendingMultiplicativeOperator = ''

        self.sumInMemory = 0.0
        self.sumSoFar = 0.0
        self.factorSoFar = 0.0
        self.waitingForOperand = True

        self.display = QLineEdit('0')
        self.display.setReadOnly(True)
        self.display.setAlignment(Qt.AlignRight)
        self.display.setMaxLength(15)

        font = self.display.font()
        font.setPointSize(font.pointSize() + 8)
        self.display.setFont(font)

        self.digitButtons = []
        
        for i in range(Calculator.NumDigitButtons):
            self.digitButtons.append(self.createButton(str(i),
                    self.digitClicked))

        self.pointButton = self.createButton(".", self.pointClicked)
        self.changeSignButton = self.createButton(u"\N{PLUS-MINUS SIGN}",
                self.changeSignClicked)

        self.backspaceButton = self.createButton("Backspace",
                self.backspaceClicked)
        self.clearButton = self.createButton("Clear", self.clear)
        self.clearAllButton = self.createButton("Clear All", self.clearAll)

        self.clearMemoryButton = self.createButton("MC", self.clearMemory)
        self.readMemoryButton = self.createButton("MR", self.readMemory)
        self.setMemoryButton = self.createButton("MS", self.setMemory)
        self.addToMemoryButton = self.createButton("M+", self.addToMemory)

        self.divisionButton = self.createButton(u"\N{DIVISION SIGN}",
                self.multiplicativeOperatorClicked)
        self.timesButton = self.createButton(u"\N{MULTIPLICATION SIGN}",
                self.multiplicativeOperatorClicked)
        self.minusButton = self.createButton("-", self.additiveOperatorClicked)
        self.plusButton = self.createButton("+", self.additiveOperatorClicked)

        self.squareRootButton = self.createButton("Sqrt",
                self.unaryOperatorClicked)
        self.powerButton = self.createButton(u"x\N{SUPERSCRIPT TWO}",
                self.unaryOperatorClicked)
        self.reciprocalButton = self.createButton("1/x",
                self.unaryOperatorClicked)
        self.equalButton = self.createButton("=", self.equalClicked)

        mainLayout = QGridLayout()
        mainLayout.setSizeConstraint(QLayout.SetFixedSize)

        mainLayout.addWidget(self.display, 0, 0, 1, 6)
        mainLayout.addWidget(self.backspaceButton, 1, 0, 1, 2)
        mainLayout.addWidget(self.clearButton, 1, 2, 1, 2)
        mainLayout.addWidget(self.clearAllButton, 1, 4, 1, 2)

        mainLayout.addWidget(self.clearMemoryButton, 2, 0)
        mainLayout.addWidget(self.readMemoryButton, 3, 0)
        mainLayout.addWidget(self.setMemoryButton, 4, 0)
        mainLayout.addWidget(self.addToMemoryButton, 5, 0)

        for i in range(1, Calculator.NumDigitButtons):
            row = ((9 - i) / 3) + 2
            column = ((i - 1) % 3) + 1
            mainLayout.addWidget(self.digitButtons[i], row, column)

        mainLayout.addWidget(self.digitButtons[0], 5, 1)
        mainLayout.addWidget(self.pointButton, 5, 2)
        mainLayout.addWidget(self.changeSignButton, 5, 3)

        mainLayout.addWidget(self.divisionButton, 2, 4)
        mainLayout.addWidget(self.timesButton, 3, 4)
        mainLayout.addWidget(self.minusButton, 4, 4)
        mainLayout.addWidget(self.plusButton, 5, 4)

        mainLayout.addWidget(self.squareRootButton, 2, 5)
        mainLayout.addWidget(self.powerButton, 3, 5)
        mainLayout.addWidget(self.reciprocalButton, 4, 5)
        mainLayout.addWidget(self.equalButton, 5, 5)
        self.setLayout(mainLayout)

        self.setWindowTitle("Calculator")

    def digitClicked(self):
        clickedButton = self.sender()
        digitValue = int(clickedButton.text())

        if self.display.text() == '0' and digitValue == 0.0:
            return

        if self.waitingForOperand:
            self.display.clear()
            self.waitingForOperand = False

        self.display.setText(self.display.text() + str(digitValue))

    def unaryOperatorClicked(self):
        clickedButton = self.sender()
        clickedOperator = clickedButton.text()
        operand = float(self.display.text())

        if clickedOperator == "Sqrt":
            if operand &lt; 0.0:
                self.abortOperation()
                return

            result = math.sqrt(operand)
        elif clickedOperator == u"x\N{SUPERSCRIPT TWO}":
            result = math.pow(operand, 2.0)
        elif clickedOperator == "1/x":
            if operand == 0.0:
                self.abortOperation()
                return

            result = 1.0 / operand

        self.display.setText(str(result))
        self.waitingForOperand = True

    def additiveOperatorClicked(self):
        clickedButton = self.sender()
        clickedOperator = clickedButton.text()
        operand = float(self.display.text())

        if self.pendingMultiplicativeOperator:
            if not self.calculate(operand, self.pendingMultiplicativeOperator):
                self.abortOperation()
                return

            self.display.setText(str(self.factorSoFar))
            operand = self.factorSoFar
            self.factorSoFar = 0.0
            self.pendingMultiplicativeOperator = ''

        if self.pendingAdditiveOperator:
            if not self.calculate(operand, self.pendingAdditiveOperator):
                self.abortOperation()
                return

            self.display.setText(str(self.sumSoFar))
        else:
            self.sumSoFar = operand

        self.pendingAdditiveOperator = clickedOperator
        self.waitingForOperand = True

    def multiplicativeOperatorClicked(self):
        clickedButton = self.sender()
        clickedOperator = clickedButton.text()
        operand = float(self.display.text())

        if self.pendingMultiplicativeOperator:
            if not self.calculate(operand, self.pendingMultiplicativeOperator):
                self.abortOperation()
                return

            self.display.setText(str(self.factorSoFar))
        else:
            self.factorSoFar = operand

        self.pendingMultiplicativeOperator = clickedOperator
        self.waitingForOperand = True

    def equalClicked(self):
        operand = float(self.display.text())

        if self.pendingMultiplicativeOperator:
            if not self.calculate(operand, self.pendingMultiplicativeOperator):
                self.abortOperation()
                return

            operand = self.factorSoFar
            self.factorSoFar = 0.0
            self.pendingMultiplicativeOperator = ''

        if self.pendingAdditiveOperator:
            if not self.calculate(operand, self.pendingAdditiveOperator):
                self.abortOperation()
                return

            self.pendingAdditiveOperator = ''
        else:
            self.sumSoFar = operand

        self.display.setText(str(self.sumSoFar))
        self.sumSoFar = 0.0
        self.waitingForOperand = True

    def pointClicked(self):
        if self.waitingForOperand:
            self.display.setText('0')

        if "." not in self.display.text():
            self.display.setText(self.display.text() + ".")

        self.waitingForOperand = False

    def changeSignClicked(self):
        text = self.display.text()
        value = float(text)

        if value &gt; 0.0:
            text = "-" + text
        elif value &lt; 0.0:
            text = text[1:]

        self.display.setText(text)

    def backspaceClicked(self):
        if self.waitingForOperand:
            return

        text = self.display.text()[:-1]
        if not text:
            text = '0'
            self.waitingForOperand = True

        self.display.setText(text)

    def clear(self):
        if self.waitingForOperand:
            return

        self.display.setText('0')
        self.waitingForOperand = True

    def clearAll(self):
        self.sumSoFar = 0.0
        self.factorSoFar = 0.0
        self.pendingAdditiveOperator = ''
        self.pendingMultiplicativeOperator = ''
        self.display.setText('0')
        self.waitingForOperand = True

    def clearMemory(self):
        self.sumInMemory = 0.0

    def readMemory(self):
        self.display.setText(str(self.sumInMemory))
        self.waitingForOperand = True

    def setMemory(self):
        self.equalClicked()
        self.sumInMemory = float(self.display.text())

    def addToMemory(self):
        self.equalClicked()
        self.sumInMemory += float(self.display.text())

    def createButton(self, text, member):
        button = Button(text)
        button.clicked.connect(member)
        return button

    def abortOperation(self):
        self.clearAll()
        self.display.setText("####")

    def calculate(self, rightOperand, pendingOperator):
        if pendingOperator == "+":
            self.sumSoFar += rightOperand
        elif pendingOperator == "-":
            self.sumSoFar -= rightOperand
        elif pendingOperator == u"\N{MULTIPLICATION SIGN}":
            self.factorSoFar *= rightOperand
        elif pendingOperator == u"\N{DIVISION SIGN}":
            if rightOperand == 0.0:
                return False

            self.factorSoFar /= rightOperand

        return True


if __name__ == '__main__':

    import sys

    app = QApplication(sys.argv)
    calc = Calculator()
    calc.show()
    sys.exit(app.exec_())</pre>
<p>參考資料:</p>
<p><a href="http://doc.qt.io/qt-5/qapplication.html">QApplication</a></p>
<p><a href="http://doc.qt.io/qt-5/qtwidgets-module.html">QtWidgets</a></p>
<p><a href="http://doc.qt.io/qt-5/qdialog.html">QDialog</a></p>
<p><a href="https://pythonspot.com/en/pyqt5-signals-and-slots/">PyQt5 Signals and Slots</a></p>
<p><a href="http://doc.qt.io/qt-5/qtwidgets-widgets-calculator-example.html">Qt 視窗計算器程式</a>&nbsp;(以 C++ 編寫)</p>
<h2>Tinkercad</h2>
<p>註冊 AutoDesk TinkerCAD 帳號</p>
<p>為了在實體 Arduino Uno 控制板連線操作之前, 可以利用網際 Auduino 控制板與電子元件系統進行模擬, 請各學員至<span>&nbsp;</span><a href="https://www.tinkercad.com/">https://www.tinkercad.com</a><span>&nbsp;</span>登記帳號, 登入後選擇左上角的 TinkerCAD 標誌連結後, 選擇 Circuits 進入電路設計與模擬, 操作畫面如下圖所示:</p>
<p><img src="/images/circuits_on_tinkercad.png" width="700" height="373" alt=""></p>
<p><span>接著選擇 Arudino Uno 控制板與 Servo Motor, 然後接上電源與地線, 並將控制訊號接到 Auduino Uno 控制板的 PWM pin 9, 利用 Code Editor 納入下列 Arduino 程式, 再利用 upload and run 將程式編譯後上傳到虛擬的 Arduino Uno 控制板上執行, 就可以模擬 Servo Motor 持續左右各旋轉 180 度. 操作畫面如下圖所示:&nbsp;</span></p>
<p><span><img src="/images/arduino_uno_servo_on_tinkercad.png" width="700" height="373" alt=""></span></p>
<p>實體 Arduino Servo Motor Control</p>
<p>完成上述以 TinkerCAD 模擬伺服馬達的接線與程式執行之後, 接著操作實體 Arduino 控制板與 Servo Motor 的控制, 首先利用電腦驅動 Arduino 控制板, 然後再利用板子上的脈衝寬度調變 (PWM, Pulse Width Modulation) 訊號控制伺服馬達, 之後再利用傳動機構與資訊控制介面, 製作所需的機電資整合系統. 電子電機系統除了可以方便感測各種物理化學量外, 還能夠快速傳遞感測與命令訊號, 而機械系統則透過機構元件的組合, 扮演傳遞功率致動或抵抗外力撞擊與疲勞破壞的角色, 至於資訊系統則用來整合各種資訊, 用更友善的人機介面, 讓使用者更有效能地運用機電資系統產品.</p>
<p><a href="https://mde1a1.kmol.info/2017fall/raw/arduino-1.8.5-windows.zip?name=4aee6f20d04156a10d1739e40f54cda7ef1b0e0e">arduino-1.8.4-windows.zip</a><span>&nbsp;</span>下載 (或直至<span>&nbsp;</span><a href="https://www.arduino.cc/en/Main/Software">https://www.arduino.cc/en/Main/Software</a><span>&nbsp;</span>下載)</p>
<p>控制台 - 硬體與音效 - 裝置管理員 利用解開的 arduino driver 程式驅動 Arduino Uno 控制板, 並取得 COM 對應號碼, 例如: COM7, 之後的 Arduino 編譯後可以透過此 COM 埠號將程式上傳到控制板上執行.</p>
<p>MG996R 伺服馬達</p>
<p>棕色線 GND</p>
<p>紅色線 V+5V</p>
<p>橘色線 PWM</p>
<p>控制程式:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">#include &lt;Servo.h&gt;
Servo myservo;  // 建立一個 servo 物件，最多可建立 12個 servo

int pos = 0;    // 設定 Servo 位置的變數

void setup() {
  myservo.attach(9);  // 將 servo 物件連接到 pin 9
}

void loop() {
  // 正轉 180度
  for (pos = 0; pos &lt;= 180; pos += 1) // 從 0 度旋轉到 180 度，每次 1 度 
  {     
    myservo.write(pos);               // 告訴 servo 走到 'pos' 的位置
    delay(15);                        // 等待 15ms 讓 servo 走到指定位置
  }

// 反轉 180度
  for (pos = 180; pos &gt;= 0; pos -= 1) // 從 180 度旋轉到 0 度，每次 1 度 
  { 
    myservo.write(pos);               // 告訴 servo 走到 'pos' 的位置

delay(15);                        // 等待 15ms 讓 servo 走到指定位置
  }
}</pre>
<p>參考資料:</p>
<p><a href="https://link.springer.com/book/10.1007/978-1-4302-3241-4">Beginning Arduino</a></p>
<p><a href="https://link.springer.com/book/10.1007/978-1-4302-3778-5">Beginning Arduino Programming</a></p>
<p><a href="http://www.playrobot.com/20kgf-cm/1150-standard-servo-mg996r.html">http://www.playrobot.com/20kgf-cm/1150-standard-servo-mg996r.html</a></p>
<p><a href="http://www.playrobot.com/freedownload/Arduino_Happy%20Learning_DEMO.pdf">http://www.playrobot.com/freedownload/Arduino_Happy%20Learning_DEMO.pdf</a></p>
<p><a href="http://atceiling.blogspot.tw/2017/03/arduino.html">http://atceiling.blogspot.tw/2017/03/arduino.html</a></p>
<p>Python, Arduino and VPython:</p>
<p><a href="http://www.toptechboy.com/arduino-lessons/">http://www.toptechboy.com/arduino-lessons/</a></p>
<p><a href="https://create.arduino.cc/projecthub/chanhj/magnetic-levitation-8c3ad0">Arduino Magnetic Levitation System</a></p>
<p><a href="http://www.instructables.com/id/Magnetic-Levitation/">http://www.instructables.com/id/Magnetic-Levitation/</a><span>&nbsp;</span>(<a href="https://www.amazon.com/Electromagnet-Solenoid-Electric-Mechanical-Experimental/dp/B008OENGU0/">電磁鐵1</a>,<span>&nbsp;</span><a href="http://goods.ruten.com.tw/item/show?21620739232041">電磁鐵2</a>)</p>
<p><a href="http://embeddedlaboratory.blogspot.tw/2017/04/design-gui-in-python-using-pyqt5.html">Arduino and PyQt5</a></p>
<p><a href="http://embeddedlaboratory.blogspot.tw/search/label/Arduino">http://embeddedlaboratory.blogspot.tw/search/label/Arduino</a></p>
<p><a href="http://electronut.in/plotting-real-time-data-from-arduino-using-python/">Arduino and Matplotlib</a></p>
<h2>讀寫網頁內容</h2>
<p>Onshape 教學影片</p>
<p><a href="https://www.onshape.com/video">https://www.onshape.com/video</a><span>&nbsp;</span>為 Onshpae 官方網站所提供的教學影片區, 請各班以每人兩個影片的方式進行分配, 分別以中文說明影片內容操作過程, 並上傳到個人的 Vimeo 與 Youtube 影片區.</p>
<p>預計分配的影片:</p>
<p><a href="https://www.onshape.com/videos/topic/tech-tips">https://www.onshape.com/videos/topic/tech-tips</a></p>
<p><a href="https://www.onshape.com/videos/topic/intro-to-cad">https://www.onshape.com/videos/topic/intro-to-cad</a></p>
<p><a href="https://www.onshape.com/videos/topic/tutorials">https://www.onshape.com/videos/topic/tutorials</a></p>
<p><a href="https://www.onshape.com/videos/topic/essential-training">https://www.onshape.com/videos/topic/essential-training</a></p>
<p><a href="https://www.onshape.com/videos/topic/drawings">https://www.onshape.com/videos/topic/drawings</a></p>
<p>請各組討論:</p>
<p>如何分配影片?如何集合管理各學員所上傳的教學操作影片?</p>
<p>利用 Python3, urllib 與 bs4 解讀上述網頁內容, 取出各影片的連結, 然後放入數列中:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from urllib.request import urlopen
from bs4 import BeautifulSoup

file = urlopen("https://www.onshape.com/videos/topic/intro-to-cad")
#print(file.read().decode())

soup = BeautifulSoup(file, 'html.parser')

links = []
for link in soup.find_all('a', href=True):
    if 'videos' in link['href']:
        if 'https' in link['href']:
            #print(link['href'])
            links.append(link['href'])
result = list(set(links))
for i in range(len(result)):
    print(i+1, result[i])</pre>
<p><span>納入上述所有影片網頁連結, 利用程式取出各影片的連結字串:</span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 從 urllib 模組中導入 urlopen
from urllib.request import urlopen
# 從 bs4 模組中導入 BeautirulSoup
from bs4 import BeautifulSoup

# 將要取出影片連結的網站 url,  放入數列中, 取名為 sources
sources = ['https://www.onshape.com/videos/topic/tech-tips', 'https://www.onshape.com/videos/topic/intro-to-cad', 'https://www.onshape.com/videos/topic/tutorials', 'https://www.onshape.com/videos/topic/essential-training', 'https://www.onshape.com/videos/topic/drawings']

#tech-tips (60)
#intro-to-cad (26)
#tutorials (14)
#essential-training (6)
#drawings (5)

# 按照網頁中的影片數計算, 共有 111 部影片, 但分類中可能重複
print(60+26+14+6+5)

# 設 links 變數與空數列對應
links = []
# 利用 for 迴圈一一取出各網頁的 html 後, 進行解讀
# 只取出有 videos 與 https 連結的資料, 但避開 all 與 topic 類別連結
for url in sources:
    file = urlopen(url)
    # 因為 urlopen 出來的資料為二位元檔案, 若要讀出列印
    # 必須要先 decode() 為字串
    #print(file.read().decode())
    # 使用 html 解讀各連結的網頁內容
    soup = BeautifulSoup(file, 'html.parser')
    # 利用 Beautifulsoup 物件中的 find_all 方法尋找 anchor
    for link in soup.find_all('a', href=True):
        # 從各 anchor 資料篩選所需的影片連結
        if ('videos' or 'https') in link['href']:
            if 'all' not in link['href']:
                if 'topic' not in link['href']:
                    links.append(link['href'])
                    
# 為避免列出重複資料, 將數列轉為集合後, 再轉回數列
result = list(set(links))
# 逐一列出所取得的影片連結
for i in range(len(result)):
    print(i+1, result[i])</pre>
<p>從<span>&nbsp;</span><a href="http://www.rfc-editor.org/search/rfc_search_detail.php?page=All&amp;title=ipv6&amp;pubstatus%5B%5D=Any&amp;pub_date_type=any&amp;sortkey=Number&amp;sorting=ASC%22">IPV6 相關 RFCs 查詢</a>得到的資料中, 如何在各組的網誌中整理一份能夠連結到各個未過時 (non-obsolete) 的 RFC 文件?</p>
<p>參考程式碼:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">data = open("midterm_list.txt").read()
line_list = data.splitlines()
count = 0
for line in line_list:
    each_line_list = line.split("\t")
    try:
        if "Obsoleted" in each_line_list[5]:
            count = count + 1
            print(each_line_list[0])
    except:
        pass
print(count)</pre>
<p>若以 Brython 改寫, 可以直接將結果列在網頁上:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&lt;div id="container"&gt;&lt;/div&gt;
 
&lt;script type="text/python3" id="script1"&gt;
from browser import document, html
container = document['container']
data = open("./../midterm_list.txt").read()
line_list = data.splitlines()
count = 0
output = ""
for line in line_list:
    each_line_list = line.split("\t")
    try:
        if "Obsoleted" not in each_line_list[5]:
            count = count + 1
            output += html.A(each_line_list[0], href="http://www.rfc-editor.org/info/"+ each_line_list[0].lower().replace(" ", "")) + " | "
            if count%10 == 0:
                output += html.BR()
    except:
        pass
output += html.BR() + html.BR()  + "共有 " + str(count)+ " 份文件尚未失效!"
container &lt;= output
&lt;/script&gt;</pre>
<p>以下則利用 Brython 讀取網站上的資料檔, 進行處理後, 將結果插入網頁:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&lt;!-- 導入 Brython 標準程式庫 --&gt;
&lt;script type="text/javascript" src="https://cdn.rawgit.com/brython-dev/brython/master/www/src/brython_dist.js"&gt;
&lt;/script&gt;
 
&lt;!-- 啟動 Brython --&gt;
&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;
 
&lt;!-- 以下利用 Brython 程式執行檔案讀取與比對流程 --&gt;
&lt;!-- 假如需要用圖型表示數字, 則利用 canvas 繪圖 --&gt;
&lt;!-- &lt;canvas id="plotarea" width="600" height="400"&gt;&lt;/canvas&gt; --&gt;
 
甲班學員投影片:
 
&lt;div id="container1"&gt;&lt;/div&gt;
 
&lt;script type="text/python3" id="script1"&gt;
from browser import document, html
container1 = document['container1']
adata = open("./../users/a.txt").read()
alist = adata.splitlines()
n = 0
for stud_num in alist:
    if stud_num == "40523148":
        mlink = html.A(stud_num, href="http://ss"+str(stud_num)+".github.io/2016fallcp_hw")
    else:
        mlink = html.A(stud_num, href="http://s"+str(stud_num)+".github.io/2016fallcp_hw")
    mlink += " | "
    n = n +1
    if n%8 == 0:
        mlink += html.BR()
    container1 &lt;= mlink
&lt;/script&gt;
 
&lt;br&gt;
甲班學員網誌:
 
&lt;div id="container2"&gt;&lt;/div&gt;
 
&lt;script type="text/python3" id="script2"&gt;
from browser import document, html
# 學員選課名單直接從 id 為 script1 的程式段中導入
from script1 import alist
container2 = document['container2']
n = 0
for stud_num in alist:
    if stud_num == "40523148":
        mlink = html.A(stud_num, href="http://ss"+str(stud_num)+".github.io/2016fallcp_hw/blog")
    else:
        mlink = html.A(stud_num, href="http://s"+str(stud_num)+".github.io/2016fallcp_hw/blog")
    mlink += " | "
    n = n +1
    if n%8 == 0:
        mlink += html.BR()
    container2 &lt;= mlink
&lt;/script&gt;</pre>
<p></p>
<h2>查英文單字</h2>
<p>利用 Python 程式協助查英文單字</p>
<p>查單字程式碼:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import urllib.request
from bs4 import BeautifulSoup
import sys, codecs
# 將系統輸出語系編碼設為 utf8
sys.stdout = codecs.getwriter("utf8")(sys.stdout.detach())
# 表示要讀入的文章檔名為 wed.txt
filename = "wed"

"""
 Project: Concordancer Jr.
 File name: concordance.py
 Description:  Counts up the number of each unique word in a block of plain text.

 Copyright (C) 2010 Steve Osborne, srosborne (at) gmail.com
 http://yakinikuman.wordpress.com/
 *******
 This program is free software; you can redistribute it and/or modify 
 it under the terms of the GNU General Public License as published by 
 the Free Software Foundation; either version 2 of the License, or 
 (at your option) any later version.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
 for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

 *******
 Version history:
 1.0   Oct 27 2010
 2.0      Nov 11, 2010 - put into a class.  Can now be called with any block of text.

"""

class Concordancer:
    def __init__(self):
        #from http://www.duboislc.org/EducationWatch/First100Words.html
        #some common words a little fishy... "water"? "oil"??  But no "am"???
        self.common = ['the','of','and','a','to','in','is','you','that','it',
            'he','was','for','on','are','as','with','his','they','i',
            'at','be','this','have','from','or','one','had','by','word',
            'but','not','what','all','were','we','when','your','can','said',
            'there','use','an','each','which','she','do','how','their','if',
            'will','up','other','about','out','many','then','them','these','so',
            'some','her','would','make','like','him','into','time','has','look',
            'two','more','write','go','see','number','no','way','could','people',
            'my','than','first','water','been','call','who','oil','its','now',
            'find','long','down','day','did','get','come','made','may','part']

        self.wordIndex = dict() #will be a count of each word in the input text
        self.total = 0 #total words
        self.unique = 0 #unique words

    def getCommon(self):
        return self.common

    def updateCommon(self,newCommon):
        #newCommon is a list of words to be used on future calls to topWordsNotCommon
        self.common = newCommon

    def extendCommon(self,newCommon):
        #newCommon is a list of words to be added to self.common
        self.common.extend(newCommon)

    def populateIndex(self,data):
        #data is a block of text
        #splits up data and adds each word to the index
        #repeated calls to populateIndex will NOT clear the index - will just keep adding up words in new block of text
        for word in data.split():#splits at and removes whitespace
            self.addword(word)
        self.calculateUniqueWords()
        self.calculateTotalWords()

    def addword(self,word):
        word = word.translate("0123456789.!?,;:*\)\(\[\]\\\n/'\"")#remove punctuation, numbers, and newlines

        if len(word) &gt; 5 and word.isalpha():
            word = word.lower()#convert to lower case
            #special case of dashes "--": separate into two words
            if "--" in word:
                words = word.replace('--',' ')
                for w in words.split():
                    self.addword(w)
            elif word in self.wordIndex:
                self.wordIndex[word] = self.wordIndex[word] + 1
            else:
                self.wordIndex[word] = 1

    def getSortedIndex(self):
        #note - sorted returns a list of tuples, not a dictionary
        s1 = sorted(list(self.wordIndex.items()),key=lambda item:item[0]) #secondary key: sort alphabetically
        s2 = sorted(s1,key=lambda item:item[1], reverse=True) #primary key: sort by count
        return s2

    def calculateUniqueWords(self):
        self.unique = len(self.wordIndex)

    def calculateTotalWords(self):
        total = 0
        for word in list(self.wordIndex.keys()):
            total = total + self.wordIndex[word]
        self.total = total

    def topWords(self,n,fExcludeCommon=1):
        #run only after "populateIndex" for meaningful output
        #returns list of top min(n,unique) words in the index
        #fExcludeCommon: if 1 [default], excludes any words in self.common.  Set to 0 to include all words.
        #returns list of (word,count) pairs for the top n words.  'count' is the count of that word.
        s2 = self.getSortedIndex()
        lwords = []
        i = 0
        while len(lwords) &lt; n and i &lt; self.unique:
            key = s2[i][0]
            value = s2[i][1]
            item = (key,value)
            if fExcludeCommon:
                if key not in self.common:
                    lwords.append(item)
            else:
                lwords.append(item)
            i = i + 1
        return lwords

# 以上為統計文章中單字出現次數的類別

def chk_dict(單字):
    url = 'http://dictionary.sina.com.tw/word/ec/'
    response = urllib.request.urlopen(url+單字)
    text = response.read()
    try:
        html_doc = text.decode("utf-8")
    except:
        html_doc = text.decode("latin-1")
    return html_doc

def parse_doc(網頁超文件):
    all_text = ""
    soup = BeautifulSoup(網頁超文件)
    div_tag = soup.findAll('div',{'class',"word_text1"})
    for i in range(len(div_tag)):
        all_text += div_tag[i].get_text()
    return all_text+"\n"

# 用來統計單字次序的全域變數
word_count = 0

def 查單字(單字):
    global word_count
    html_doc = chk_dict(單字)
    our_text = parse_doc(html_doc)
    if our_text == "\n":
        word_def = "查不到與 "+單字+" 有關的資料\n"
    else:
        word_count += 1
        word_def = str(word_count)+". "+單字+":\n"
        word_def += our_text
    word_def += "_"*50+"\n"
    return word_def

# 檔案是要將結果存檔用的 handle
檔案 = open("words_"+filename+".txt", "w", encoding="UTF-8")

# 以下為統計文章單字用的程式呼叫
concord = Concordancer()
file = filename+'.txt'
f = open(file,'rt',encoding="utf-8")
data = f.read()#the whole file as one big string
concord.populateIndex(data)

n = concord.unique
print("Top %s words:" % n)
top = concord.topWords(n)

# 隨後的 key 就是單字
order = 0
all_text = ""
for item in top:
    order += 1
    key = item[0]
    value = item[1]
    #print(order,"%s:%s" % (key,value))
    print(order,key,value)
    all_text += 查單字(key)

檔案.write(all_text)
print("done")</pre>
<h2>docx 轉 pdf</h2>
<p>用來學習 Onshape 的教學檔案格式為 docx, 以下使用 Windows 環境下的 Python3 程式, 自動進入各教學檔案目錄, 將 docx 轉為 pdf</p>
<p>首先必須以 pip install comtypes 安裝 comtypes 模組, 然後以 SciTE, 在教學檔案目錄中, 利用以下程式碼建立 docx2pdf.py 後執行, 即可將所有 56 個 docx 轉出 pdf 檔案.</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import sys
import os
import comtypes.client
 
wdFormatPDF = 17
 
#in_file = input("input docx")
#out_file = input("output filename")
 
def docx2pdf(in_file, out_file):
    word = comtypes.client.CreateObject('Word.Application')
    doc = word.Documents.Open(in_file)
    doc.SaveAs(out_file, FileFormat=wdFormatPDF)
    doc.Close()
    word.Quit()
 
count = 0
# traverse root directory, and list directories as dirs and files as files
for root, dirs, files in os.walk(os.getcwd()):
    #print(root)
    path = root.split('/')
    #print(path)
    #print((len(path) - 1) * '---', os.path.basename(root))
    #print(files)
    for file in files:
        #print(len(path) * '---', file)
        file_ext = file.split(".")[1]
        file_name = file.split(".")[0]
        #print(file_ext)
        if file_ext == "docx":
            count = count + 1
            in_file = path[0] + "/" + file
            #print(count,":", in_file)
            out_file = path[0] + "/" + file_name + ".pdf"
            #print(out_file)
            docx2pdf(in_file, out_file)
 
#print(count)
#docx2pdf(in_file, out_file)
print("done")</pre>
<p></p>
<h2>網際繪圖</h2>
<p>網頁中有三種基本元素 HTML5, CSS 與 Javascript, 透過 <a href="https://brython.info/">Brython</a> 或 <a href="https://github.com/fengari-lua/fengari-web">Fengari-web</a>, 使用者可以以 Python 及 Lua 替代 Javascript.</p>
<p>參考資料:&nbsp;<a href="https://link.springer.com/book/10.1007/978-1-4842-2463-2">Pro HTML5 with CSS, JavaScript, and Multimedia.pdf</a></p>
<!-- 啟動 brython() 暫時不用
<p>
<script>
window.onload=function(){
brython(1);
}
</script>
--><!-- 以下利用 Brython 程式執行繪圖 暫時不用
<p><canvas id="taiwan_flag" width="300" height="200"></canvas></p>
<p>
<script type="text/python3">
# 導入 doc
from browser import document as doc
import math

# 準備繪圖畫布
canvas = doc["taiwan_flag"]
ctx = canvas.getContext("2d")
# 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點
# ctx.setTransform(1, 0, 0, -1, 0, canvas.height)
# 以下採用 canvas 原始座標繪圖
flag_w = canvas.width
flag_h = canvas.height
circle_x = flag_w/4
circle_y = flag_h/4
# 先畫滿地紅
ctx.fillStyle='rgb(255, 0, 0)'
ctx.fillRect(0,0,flag_w,flag_h)
# 再畫青天
ctx.fillStyle='rgb(0, 0, 150)'
ctx.fillRect(0,0,flag_w/2,flag_h/2)
# 畫十二道光芒白日
ctx.beginPath()
star_radius = flag_w/8
angle = 0
for i in range(24):
    angle += 5*math.pi*2/12
    toX = circle_x + math.cos(angle)*star_radius
    toY = circle_y + math.sin(angle)*star_radius
    # 只有 i 為 0 時移動到 toX, toY, 其餘都進行 lineTo
    if (i):
        ctx.lineTo(toX, toY)
    else:
        ctx.moveTo(toX, toY)
ctx.closePath()
# 將填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
# 白日:藍圈
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, True)
ctx.closePath()
# 填色設為藍色
ctx.fillStyle = 'rgb(0, 0, 149)'
ctx.fill()
# 白日:白心
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, True)
ctx.closePath()
# 填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
</script>
-->
<p><img src="/images/taiwan_flag.png" width="500" height="333" alt=""></p>
<p>上圖原始碼:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&lt;!-- for Brython --&gt;
&lt;script src="https://scrum-3.github.io/web/brython/brython.js"&gt;&lt;/script&gt;
&lt;script src="https://scrum-3.github.io/web/brython/brython_stdlib.js"&gt;&lt;/script&gt;
&lt;!-- 啟動 brython() --&gt;
&lt;p&gt;
&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;
&lt;/p&gt;
&lt;!-- 以下利用 Brython 程式執行繪圖 --&gt;
&lt;p&gt;&lt;canvas id="taiwan_flag" width="300" height="200"&gt;&lt;/canvas&gt;&lt;/p&gt;
&lt;p&gt;
&lt;script type="text/python3"&gt;
# 導入 doc
from browser import document as doc
import math

# 準備繪圖畫布
canvas = doc["taiwan_flag"]
ctx = canvas.getContext("2d")
# 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點
# ctx.setTransform(1, 0, 0, -1, 0, canvas.height)
# 以下採用 canvas 原始座標繪圖
flag_w = canvas.width
flag_h = canvas.height
circle_x = flag_w/4
circle_y = flag_h/4
# 先畫滿地紅
ctx.fillStyle='rgb(255, 0, 0)'
ctx.fillRect(0,0,flag_w,flag_h)
# 再畫青天
ctx.fillStyle='rgb(0, 0, 150)'
ctx.fillRect(0,0,flag_w/2,flag_h/2)
# 畫十二道光芒白日
ctx.beginPath()
star_radius = flag_w/8
angle = 0
for i in range(24):
    angle += 5*math.pi*2/12
    toX = circle_x + math.cos(angle)*star_radius
    toY = circle_y + math.sin(angle)*star_radius
    # 只有 i 為 0 時移動到 toX, toY, 其餘都進行 lineTo
    if (i):
        ctx.lineTo(toX, toY)
    else:
        ctx.moveTo(toX, toY)
ctx.closePath()
# 將填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
# 白日:藍圈
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, True)
ctx.closePath()
# 填色設為藍色
ctx.fillStyle = 'rgb(0, 0, 149)'
ctx.fill()
# 白日:白心
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, True)
ctx.closePath()
# 填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
&lt;/script&gt;
&lt;/p&gt;</pre>
<p></p>
<h2>V-rep</h2>
<p><a href="http://lab.kmol.info/2017fall/blog/kmol-2017-fall-event-driven-programming-design.html">http://lab.kmol.info/2017fall/blog/kmol-2017-fall-event-driven-programming-design.html</a>&nbsp;</p>
<h2>輔助設計套件</h2>
<p>MCAD 套件</p>
<p><a href="http://lab.kmol.info/2017fall/blog/kmol-2017-fall-cadp-what-is-computer-aided-design.html">http://lab.kmol.info/2017fall/blog/kmol-2017-fall-cadp-what-is-computer-aided-design.html</a>&nbsp;</p>
<p>一般常見的機械電腦輔助設計套件包括法國<span>&nbsp;</span><a href="https://www.3ds.com/">Dassault</a><span>&nbsp;</span>公司的<span>&nbsp;</span><a href="https://www.3ds.com/products-services/solidworks/">SolidWorks</a><span>&nbsp;</span>與<span>&nbsp;</span><a href="https://www.3ds.com/products-services/catia/">Catia</a>, 美國<span>&nbsp;</span><a href="https://www.autodesk.com.tw/">AutoDesk</a><span>&nbsp;</span>公司的<span>&nbsp;</span><a href="https://www.autodesk.com.tw/products/autocad/">AutoCAD</a><span>&nbsp;</span>與<span>&nbsp;</span><a href="https://www.autodesk.com/products/inventor/overview">Inventor</a>, 德國<span>&nbsp;</span><a href="https://www.siemens.com/tw/zh/home.html">Siemens</a><span>&nbsp;</span>公司的<span>&nbsp;</span><a href="https://www.plm.automation.siemens.com/en/products/solid-edge/">Solid Edge</a><span>&nbsp;</span>與<span>&nbsp;</span><a href="https://www.plm.automation.siemens.com/zh/products/nx/index.shtml">NX</a>, 美國<span>&nbsp;</span><a href="http://www.ptc-taiwan.com/">PTC</a><span>&nbsp;</span>公司的<span>&nbsp;</span><a href="http://www.ptc-taiwan.com/cad">Creo</a>, 以及 2015 年推出的<span>&nbsp;</span><a href="https://www.onshape.com/">Onshape</a></p>
<p>其他 MCAD: 俄羅斯的<span>&nbsp;</span><a href="http://www.tflex.com/resources/tflexcadst/download/">T-Flex</a></p>
<p>如何進行電腦輔助機械設計專題</p>
<p>1. 文獻回顧 (Literature Review) 階段 - 了解現存既有的研究成果, 確立專題定位與目標</p>
<p>利用關鍵字搜尋相關文獻, 針對文獻回顧與探討, 初步定位專案性質以及從事專案的目標.</p>
<p>例如, 關鍵字:<span>&nbsp;</span><a href="https://www.google.com.tw/search?q=marble+machine+construction+set">marble machine construction set</a>,<span>&nbsp;</span><a href="https://www.google.com.tw/search?q=linkage+synthesis">linkage synthesis</a>,<span>&nbsp;</span><a href="https://www.google.com.tw/search?q=arduino+mechatronics">arduino mechatronics</a>,<span>&nbsp;</span><a href="https://www.google.com.tw/search?q=arduino+servo+control">arduino servo control</a>,<span>&nbsp;</span><a href="https://www.google.com.tw/search?q=lifter+linkage">lifter linkage</a>,<span>&nbsp;</span><a href="https://mde1a1.kmol.info/2017fall/raw/doing+a+literature+review.pdf?name=566d6dab70c1a7e7458a2c10c667416fea048170">Doing a Literature Review</a></p>
<p>2. 整理可用工具, 擬想何謂機械?何謂設計?何謂電腦輔助?擬想所要解決的問題, 準備開始進行電腦輔助機械設計專題</p>
<p>機械是一種功能明確的器物, 內容包含固體、流體與軟體元件, 彼此精巧配置結合, 可展現特定功能</p>
<p>設計是一種表達, 而且是可以讓人依循, 逐步按照指示, 完成設計者預想的結果, 且表達方法包含文字、口語、2D、3D、數學與實體方法.</p>
<p>文字結合 2D、3D、數學表達方法 - 設計專題報告</p>
<p>利用口語簡報設計專題內容 - 設計專題報告影片</p>
<p>電腦輔助 - 利用電腦的功能協助設計進行</p>
<p>電腦功能 - 設計組態管理、運算、模擬、網路資訊傳輸、展示、協同</p>
<p>例如:</p>
<p>零組件繪圖工具:<span>&nbsp;</span><a href="http://solvespace.com/">Solvespace</a><span>&nbsp;</span>(包含在隨身系統),<span>&nbsp;</span><a href="http://www.onshape.com/">Onshape</a><span>&nbsp;</span>(自行申請帳號),<span>&nbsp;</span><a href="http://www.ptc-taiwan.com/cad/creo">PTC Creo Parametric</a><span>&nbsp;</span>(可從區網下載可攜網路認證版本) ,<span>&nbsp;</span><a href="https://www.autodesk.com/products/inventor/overview">Autodesk Inventor</a><span>&nbsp;</span>(可自行申請免費學生版本或安裝系上提供之網路認證版本),<span>&nbsp;</span><a href="http://www.solidworks.com.cn/">Dassault Solidworks</a><span>&nbsp;</span>(可安裝學校提供之網路認證版本).</p>
<p>協同工具:<span>&nbsp;</span><a href="http://www.onshape.com/">Onshape</a><span>&nbsp;</span>(自行申請帳號),<span>&nbsp;</span><a href="https://a360.autodesk.com/">A360</a><span>&nbsp;</span>(自行申請帳號)</p>
<p>模擬工具:<span>&nbsp;</span><a href="http://www.coppeliarobotics.com/">V-rep</a><span>&nbsp;</span>(包含在隨身系統),<span>&nbsp;</span><a href="https://www.blender.org/">Blender</a><span>&nbsp;</span>(包含在隨身系統),<span>&nbsp;</span><a href="https://www.tinkercad.com/">Tinkercad</a><span>&nbsp;</span>(自行申請帳號)</p>
<p>控制與致動工具:<span>&nbsp;</span><a href="https://www.arduino.cc/">Arduino</a><span>&nbsp;</span>(包含在工具箱中),<span>&nbsp;</span><a href="http://www.instructables.com/id/Arduino-Servo-Motors/">Servo Motor</a><span>&nbsp;</span>(包含在工具箱中)</p>
<p>3D 列印工具:<span>&nbsp;</span><a href="http://atom3dp.com/">Delta Printer</a><span>&nbsp;</span>(由系上實習設備提供)</p>
<p>3. 根據專題定位與目標, 確定所要解決的問題項目, 逐一採模組式, 以協同流程, 透過自學、執行與檢討想像, 由簡入繁, 持續改進各模組的內容與功能, 在可用時間內, 解決各種問題, 終至完成專題, 達成目標.</p>
<p>鋼球循環運動系統設計</p>
<p>機構設計 - 軌道設計、鋼球提升與傳動系統設計、其他零組件設計</p>
<p>致動與控制系統設計 - 電路設計、伺服馬達致動程式設計</p>
<p>監控程式設計 - 以視窗程式啟動系統運作、傳回鋼球通過控制點訊息、計算運行距離與速度</p>
<p>marble lift mechanism</p>
<p>四連桿浮動桿通過三個位置的尺寸合成設計</p>
<p>六連桿尺寸合成</p>
<p>八連桿尺寸合成</p>
<p><a href="http://www.eddiesmind.com/basic-lifting-mechanisms.html">http://www.eddiesmind.com/basic-lifting-mechanisms.html</a></p>
<p>Linkage:<span>&nbsp;</span><a href="http://blog.rectorsquid.com/linkage-mechanism-designer-and-simulator/">http://blog.rectorsquid.com/linkage-mechanism-designer-and-simulator/</a><span>&nbsp;</span>(<a href="https://github.com/rectorsquid/Linkage">Source codes</a>)</p>
<p>LinkageDesigner (an add-on package to Wolfram's Mathematica):<span>&nbsp;</span><a href="http://www.linkagedesigner.com/">http://www.linkagedesigner.com/</a>,<span>&nbsp;</span><a href="https://www.wolfram.com/products/applications/linkagedesigner/">https://www.wolfram.com/products/applications/linkagedesigner/</a></p>
<p><a href="https://github.com/KmolYuan/Pyslvs-PyQt5">https://github.com/KmolYuan/Pyslvs-PyQt5</a></p>
<h1>分組專題</h1>
<p>分組專題報告</p>
<p>章節</p>
<ul>
<li>標題頁 - 含報告標題、作者、日期與所屬單位</li>
<li>目錄 - 列出全文章節與所屬頁面連結</li>
<li>摘要 - 解釋報告編寫動機、報告重點、結論、建議與關鍵字</li>
<li>前言 - 簡要描述全文意旨與背景, 說明報告目標與報告內容組成架構</li>
<li>內文 - 依照章節標題, 詳細說明報告內容, 包括方法、操作步驟與所得結果的詳細說明</li>
<li>結論 - 條列所獲致的重要成果, 與摘要及導言中的目標互相呼應</li>
<li>討論與建議 - 說明後續值得進行的方向、方法與可能遭遇問題的討論</li>
<li>參考 - 詳列所引用的參考內容</li>
<li>附錄 - 附加值得參考的詳細內容</li>
</ul>
<h2>分組題目</h2>
<p><a href="https://github.com/mdecourse/wcms-scrum1">https://github.com/mdecourse/wcms-scrum1</a>&nbsp;</p>
<p>單機工程用計算機設計</p>
<p>網際工程用計算機設計</p>
<p>正齒輪嚙合傳動齒面寬設計</p>
<p>網際 PMKS (Planar Mechanism Kinematic Simulator):&nbsp;<a href="https://designengrlab.github.io/PMKS/">https://designengrlab.github.io/PMKS/</a>&nbsp;</p>
<p><a href="https://design.engr.oregonstate.edu/matthew-campbell-phd-dissertation">https://design.engr.oregonstate.edu/matthew-campbell-phd-dissertation</a>&nbsp; or&nbsp;<a href="/downloads/matthew_i_campbell_phd_dissertation.pdf">The A-Design Invention Machine.pdf</a></p>
<p><a href="https://ir.library.oregonstate.edu/downloads/2801pk71p">Automated Synthesis of Planar Mechanisms with Revolute, Prismatic and Pin-In-Slot Joints.pdf</a>&nbsp;(or <a href="/downloads/2015Automated%20Synthesis of Planar Mechanisms with Revolute Prismatic.pdf">local</a>)</p>
<p>Gruebler&rsquo;s Equation</p>
<p>Degrees of freedom for planar linkages joined with common joints can be calculated through Gruebler&rsquo;s equation.</p>
<p>Gruebler&rsquo;s equation is given by the formula:<br>Gruebler's equation formula for calculating degrees of freedom</p>
<p>dof = 3(n-1)-2jp-jh</p>
<p>where,<br>n = total number of links in the mechanism<br>jp = total number of primary joints (pins or sliding joints)<br>jh = total number of higher-order joints (cam or gear joints)</p>
<p>Exception to Gruebler&rsquo;s Equation:</p>
<p>The Gruebler&rsquo;s equation does not account for link geometry, in rare instances, it can lead to misleading results.</p>
<p>Notice that the linkage contains five links and six pin joints. Using Gruebler&rsquo;s equation, this linkage has zero degrees of freedom. Of course, this suggests that the mechanism is locked. However, if all pivoted links were the same size and the distance between the joints on the frame and coupler were identical, this mechanism is capable of motion, with a single degree of freedom. The center link is redundant and because it is identical in length to the other two links attached to the frame, it does not alter the action of the linkage.</p>
<p>There are other examples of mechanisms that violate the Gruebler&rsquo;s equation because of unique geometry. A designer must be aware that the mobility equation can, at times, lead to inconsistencies.</p>
<p>A graph consists of a set of vertices (points) together with a set of edges or lines.<br>The set of vertices is connected by the set of edges. Let the graph be denoted by<br>the symbol G, the vertex by set V , and the edge by set E. We call a graph with v<br>vertices and e edges a (v, e) graph. Edges and vertices in a graph should be labeled<br>or colored, otherwise they are indistinguishable.<br>Each edge of a graph connects two vertices called the end points. We specify an<br>edge by its end points; that is, eij denotes the edge connecting vertices i and j . An<br>edge is said to be incident with a vertex, if the vertex is an end point of that edge.<br>The two end points of an edge are said to be adjacent. Two edges are adjacent if they<br>are incident to a common vertex.</p>
<h2>符號式推導</h2>
<p>使用 Python 的符號式推導前, 需要先安裝 <a href="https://github.com/sympy/sympy">sympy</a> 模組:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">python -m pip install sympy</pre>
<p>參考資料:&nbsp;<a href="https://github.com/mdecourse/2017springcd/tree/gh-pages/data">https://github.com/mdecourse/2017springcd/tree/gh-pages/data</a>&nbsp;</p>
<p>PLAP - 已知三角形 abc,&nbsp; <span style="background-color: #ffff00;">P</span>oint a 座標, <span style="background-color: #ffff00;">L</span>ength of a to C, and <span style="background-color: #ffff00;">A</span>ngle of ac link relative to ab, and <span style="background-color: #ffff00;">P</span>oint b 座標.</p>
<p>求 c 點座標, 表示為已知輸入變數的方程式.</p>
<p><img src="/download/?type=images&amp;filename=fourbar_plap_solvespace.png" alt="" width="800" height="486"><img src="/images/plap.png" width="800" height="487" alt=""></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">#PLAP
from sympy import symbols, sqrt, solve, cos, sin, Abs

# inputs
ax, ay, bx, by, bac, ac = symbols('ax ay bx by bac ac')
# intermediate variables
ab, dab = symbols('ab dab')
ad, bd = symbols('ad bd')
# outputs
cx, cy = symbols('cx cy')
# 從 a, b 點座標求 ab, ad 與 bd
ab = sqrt((ax-bx)**2+(ay-by)**2)
ad = Abs(bx-ax)
bd = Abs(by-ay)
data = solve(-bd**2+ad**2+ab**2-2*ad*ab*cos(dab), dab)
# 第1組解
dab = data[0]
cx = ax+ac*cos(dab+bac)
cy = ay+ac*sin(dab+bac)
print("cx=", cx, "cy=", cy)
# 第二組解
dab = data[1]
cx = ax+ac*cos(dab+bac)
cy = ay+ac*sin(dab+bac)
print("cx=", cx, "cy=", cy)</pre>
<p>PLLP - 已知三角形 abc,&nbsp; 順時鐘方向 Point a 座標,&nbsp; Length of ac 與 Length of cb, 以及 Point b 座標.</p>
<p>求 c 點座標, 表示為已知輸入變數的方程式.</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">#PLLP
from sympy import symbols, sqrt, solve, cos, sin, Abs

# inputs
ax, ay, bx, by, ac, cb = symbols('ax ay bx by ac cb')
# intermediate variables
ab, dab, bac, degree= symbols('ab dab bac degree')
ad, bd = symbols('ad bd')
# outputs
cx, cy = symbols('cx cy')
# 從 a, b 點座標求 ab, ad 與 bd

ab = sqrt((ax-bx)**2+(ay-by)**2)
'''
ac = sqrt((ax-cx)**2+(ay-cy)**2)
cb = sqrt((cx-bx)**2+(cy-by)**2)
#ac = sqrt((ax-cx)**2+(ay-cy)**2)
'''
# 從兩組解中擇一
data = solve([ac**2-((ax-cx)**2+(ay-cy)**2), cb**2-((cx-bx)**2+(cy-by)**2)], [cx, cy])
# 第1組解
print("cx = ", data[0][0])
print("cy = ", data[1][0])
# 第2組解
print("cx = ", data[0][1])
print("cy = ", data[1][1])
</pre>
<p>PLPP - 已知 Point b 座標, Length of be, Point c 座標與 Point d 座標.</p>
<p>求 e 點座標, 表示為已知輸入變數的方程式.</p>
<p><img src="/download/?type=images&amp;filename=plpp_crank_slider.png" alt="" width="800" height="446"><img src="/images/plpp.png" width="800" height="445" alt=""></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">#PLPP
from sympy import symbols, sqrt, solve

# inputs
bx, by, be, cx, cy, dx, dy = symbols('bx by be cx cy dx dy')
# intermediate variables
cd, m= symbols('cd m')
# outputs
ex, ey = symbols('ex ey')
# e on line cd
cd = sqrt((cx-dx)**2+(cy-dy)**2)
m = (dx-cx)/(dy-cy)
data = solve([be-sqrt((bx-ex)**2+(by-ey)**2), ex-cx-m*(ey-cy)] ,  [ex, ey])
print(data)
'''
[(((cx - dx)*(bx*cx*cy - bx*cx*dy - bx*cy*dx + bx*dx*dy + by*cy**2 - 2*by*cy*dy + by*dy**2 + cx**2*dy - cx*cy*dx - cx*dx*dy + cy*dx**2 + (-cy + dy)*sqrt(be**2*cx**2 - 2*be**2*cx*dx + be**2*cy**2 - 2*be**2*cy*dy + be**2*dx**2 + be**2*dy**2 - bx**2*cy**2 + 2*bx**2*cy*dy - bx**2*dy**2 + 2*bx*by*cx*cy - 2*bx*by*cx*dy - 2*bx*by*cy*dx + 2*bx*by*dx*dy - 2*bx*cx*cy*dy + 2*bx*cx*dy**2 + 2*bx*cy**2*dx - 2*bx*cy*dx*dy - by**2*cx**2 + 2*by**2*cx*dx - by**2*dx**2 + 2*by*cx**2*dy - 2*by*cx*cy*dx - 2*by*cx*dx*dy + 2*by*cy*dx**2 - cx**2*dy**2 + 2*cx*cy*dx*dy - cy**2*dx**2)) - (cx*dy - cy*dx)*(cx**2 - 2*cx*dx + cy**2 - 2*cy*dy + dx**2 + dy**2))/((cy - dy)*(cx**2 - 2*cx*dx + cy**2 - 2*cy*dy + dx**2 + dy**2)), (bx*cx*cy - bx*cx*dy - bx*cy*dx + bx*dx*dy + by*cy**2 - 2*by*cy*dy + by*dy**2 + cx**2*dy - cx*cy*dx - cx*dx*dy + cy*dx**2 + (-cy + dy)*sqrt(be**2*cx**2 - 2*be**2*cx*dx + be**2*cy**2 - 2*be**2*cy*dy + be**2*dx**2 + be**2*dy**2 - bx**2*cy**2 + 2*bx**2*cy*dy - bx**2*dy**2 + 2*bx*by*cx*cy - 2*bx*by*cx*dy - 2*bx*by*cy*dx + 2*bx*by*dx*dy - 2*bx*cx*cy*dy + 2*bx*cx*dy**2 + 2*bx*cy**2*dx - 2*bx*cy*dx*dy - by**2*cx**2 + 2*by**2*cx*dx - by**2*dx**2 + 2*by*cx**2*dy - 2*by*cx*cy*dx - 2*by*cx*dx*dy + 2*by*cy*dx**2 - cx**2*dy**2 + 2*cx*cy*dx*dy - cy**2*dx**2))/(cx**2 - 2*cx*dx + cy**2 - 2*cy*dy + dx**2 + dy**2)), (((cx - dx)*(bx*cx*cy - bx*cx*dy - bx*cy*dx + bx*dx*dy + by*cy**2 - 2*by*cy*dy + by*dy**2 + cx**2*dy - cx*cy*dx - cx*dx*dy + cy*dx**2 + (cy - dy)*sqrt(be**2*cx**2 - 2*be**2*cx*dx + be**2*cy**2 - 2*be**2*cy*dy + be**2*dx**2 + be**2*dy**2 - bx**2*cy**2 + 2*bx**2*cy*dy - bx**2*dy**2 + 2*bx*by*cx*cy - 2*bx*by*cx*dy - 2*bx*by*cy*dx + 2*bx*by*dx*dy - 2*bx*cx*cy*dy + 2*bx*cx*dy**2 + 2*bx*cy**2*dx - 2*bx*cy*dx*dy - by**2*cx**2 + 2*by**2*cx*dx - by**2*dx**2 + 2*by*cx**2*dy - 2*by*cx*cy*dx - 2*by*cx*dx*dy + 2*by*cy*dx**2 - cx**2*dy**2 + 2*cx*cy*dx*dy - cy**2*dx**2)) - (cx*dy - cy*dx)*(cx**2 - 2*cx*dx + cy**2 - 2*cy*dy + dx**2 + dy**2))/((cy - dy)*(cx**2 - 2*cx*dx + cy**2 - 2*cy*dy + dx**2 + dy**2)), (bx*cx*cy - bx*cx*dy - bx*cy*dx + bx*dx*dy + by*cy**2 - 2*by*cy*dy + by*dy**2 + cx**2*dy - cx*cy*dx - cx*dx*dy + cy*dx**2 + (cy - dy)*sqrt(be**2*cx**2 - 2*be**2*cx*dx + be**2*cy**2 - 2*be**2*cy*dy + be**2*dx**2 + be**2*dy**2 - bx**2*cy**2 + 2*bx**2*cy*dy - bx**2*dy**2 + 2*bx*by*cx*cy - 2*bx*by*cx*dy - 2*bx*by*cy*dx + 2*bx*by*dx*dy - 2*bx*cx*cy*dy + 2*bx*cx*dy**2 + 2*bx*cy**2*dx - 2*bx*cy*dx*dy - by**2*cx**2 + 2*by**2*cx*dx - by**2*dx**2 + 2*by*cx**2*dy - 2*by*cx*cy*dx - 2*by*cx*dx*dy + 2*by*cy*dx**2 - cx**2*dy**2 + 2*cx*cy*dx*dy - cy**2*dx**2))/(cx**2 - 2*cx*dx + cy**2 - 2*cy*dy + dx**2 + dy**2))]
'''


</pre>
<h2>網際平面連桿模擬</h2>
<p>Brython 程式碼:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;canvas id="plotarea" width="600" height="450"&gt;&lt;/canvas&gt;

&lt;script type="text/python3"&gt;
from browser import document
import math
import time
from browser import timer

class Coord(object):
    def __init__(self,x,y):
        self.x = x
        self.y = y

    def __sub__(self,other):
        # This allows you to substract vectors
        return Coord(self.x-other.x,self.y-other.y)

    def __repr__(self):
        # Used to get human readable coordinates when printing
        return "Coord(%f,%f)"%(self.x,self.y)

    def length(self):
        # Returns the length of the vector
        return math.sqrt(self.x**2 + self.y**2)

    def angle(self):
        # Returns the vector's angle
        return math.atan2(self.y,self.x)

def normalize(coord):
    return Coord(
        coord.x/coord.length(),
        coord.y/coord.length()
        )

def perpendicular(coord):
    # Shifts the angle by pi/2 and calculate the coordinates
    # using the original vector length
    return Coord(
        coord.length()*math.cos(coord.angle()+math.pi/2),
        coord.length()*math.sin(coord.angle()+math.pi/2)
        )

# 點類別
class Point(object):
    # 起始方法
    def __init__(self, x, y):
        self.x = x
        self.y = y

    # 繪製方法
    def drawMe(self, g, r):
        self.g = g
        self.r = r
        self.g.save()
        self.g.moveTo(self.x,self.y)
        self.g.beginPath()
        # 根據 r 半徑繪製一個圓代表點的所在位置
        self.g.arc(self.x, self.y, self.r, 0, 2*math.pi, True)
        self.g.moveTo(self.x,self.y)
        self.g.lineTo(self.x+self.r, self.y)
        self.g.moveTo(self.x, self.y)
        self.g.lineTo(self.x-self.r, self.y)
        self.g.moveTo(self.x, self.y)
        self.g.lineTo(self.x, self.y+self.r)
        self.g.moveTo(self.x, self.y)
        self.g.lineTo(self.x, self.y-self.r)
        self.g.restore()
        self.g.stroke()

    # 加入 Eq 方法
    def Eq(self, pt):
        self.x = pt.x
        self.y = pt.y

    # 加入 setPoint 方法
    def setPoint(self, px, py):
        self.x = px
        self.y = py

    # 加上 distance(pt) 方法, 計算點到 pt 的距離
    def distance(self, pt):
        self.pt = pt
        x = self.x - self.pt.x
        y = self.y - self.pt.y
        return math.sqrt(x * x + y * y)

    # 利用文字標示點的座標位置
    def tag(self, g):
        self.g = g
        self.g.beginPath()
        self.g.fillText("%d, %d"%(self.x, self.y),self.x, self.y)
        self.g.stroke()


# Line 類別物件
class Line(object):

    # 起始方法
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        # 直線的第一點, 設為線尾
        self.Tail = self.p1
        # 直線組成的第二點, 設為線頭
        self.Head = self.p2
        # 直線的長度屬性
        self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))

    # setPP 以指定頭尾座標點來定義直線
    def setPP(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        self.Tail = self.p1
        self.Head = self.p2
        self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))

    # setRT 方法 for Line, 應該已經確定 Tail 點, 然後以 r, t 作為設定 Head 的參考
    def setRT(self, r, t):
        self.r = r
        self.t = t
        x = self.r * math.cos(self.t)
        y = self.r * math.sin(self.t)
        self.Tail.Eq(self.p1)
        self.Head.setPoint(self.Tail.x + x,self.Tail.y + y)

    # getR 方法 for Line
    def getR(self):
        # x 分量與 y 分量
        x = self.p1.x - self.p2.x
        y = self.p1.y - self.p2.y
        return math.sqrt(x * x + y * y)

    # 根據定義 atan2(y,x), 表示 (x,y) 與 正 x 軸之間的夾角, 介於 pi 與 -pi 間
    def getT(self):
        x = self.p2.x - self.p1.x
        y = self.p2.y - self.p1.y
        if (math.fabs(x) &lt; math.pow(10,-100)):
            if(y &lt; 0.0):
                return (-math.pi/2)
            else:
                return (math.pi/2)
        else:
            return math.atan2(y, x)

    # setTail 方法 for Line
    def setTail(self, pt):
        self.pt = pt
        self.Tail.Eq(pt)
        self.Head.setPoint(self.pt.x + self.x, self.pt.y + self.y)

    # getHead 方法 for Line
    def getHead(self):
        return self.Head

    def getTail(self):
        return self.Tail

    def drawMe(self, g):
        self.g = g
        self.g.beginPath()
        self.g.moveTo(self.p1.x,self.p1.y)
        self.g.lineTo(self.p2.x,self.p2.y)
        self.g.stroke()

    def test(self):
        return ("this is pure test to Inherit")


class Link(Line):
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        self.length = math.sqrt(math.pow((self.p2.x - self.p1.x), 2) + math.pow((self.p2.y - self.p1.y), 2))

    #g context
    def drawMe(self, g):
        self.g = g
        hole = 5
        radius = 10
        length = self.getR()
        # alert(length)
        # 儲存先前的繪圖狀態
        self.g.save()
        self.g.translate(self.p1.x,self.p1.y)
        #alert(str(self.p1.x)+","+str(self.p1.y))
        #self.g.rotate(-((math.pi/2)-self.getT()))
        self.g.rotate(-math.pi*0.5 + self.getT())
        #alert(str(self.getT()))
        #self.g.rotate(10*math.pi/180)
        #this.g.rotate(-(Math.PI/2-this.getT()));
        # 必須配合畫在 y 軸上的 Link, 進行座標轉換, 也可以改為畫在 x 軸上...
        self.g.beginPath()
        self.g.moveTo(0,0)
        self.g.arc(0, 0, hole, 0, 2*math.pi, True)
        self.g.stroke()
        self.g.moveTo(0,length)
        self.g.beginPath()
        self.g.arc(0,length, hole, 0, 2*math.pi, True)
        self.g.stroke()
        self.g.moveTo(0,0)
        self.g.beginPath()
        self.g.arc(0,0, radius, 0, math.pi, True)
        self.g.moveTo(0+radius,0)
        self.g.lineTo(0+radius,0+length)
        self.g.stroke()
        self.g.moveTo(0,0+length)
        self.g.beginPath()
        self.g.arc(0, 0+length, radius, math.pi, 0, True)
        self.g.moveTo(0-radius,0+length)
        self.g.lineTo(0-radius,0)
        self.g.stroke()
        self.g.restore()
        '''
        self.g.beginPath()
        self.g.fillStyle = "red"
        self.g.font = "bold 18px sans-serif"
        self.g.fillText("%d, %d"%(self.p2.x, self.p2.y),self.p2.x, self.p2.y)
        self.g.stroke()
        '''


class Triangle(object):
    def __init__(self, p1, p2, p3):
        self.p1 = p1
        self.p2 = p2
        self.p3 = p3

    def getLenp3(self):
        p1 = self.p1
        ret = p1.distance(self.p2)
        return ret

    def getLenp1(self):
        p2 = self.p2
        ret = p2.distance(self.p3)
        return ret

    def getLenp2(self):
        p1 = self.p1
        ret = p1.distance(self.p3)
        return ret

    # 角度
    def getAp1(self):
        ret = math.acos(((self.getLenp2() * self.getLenp2() + self.getLenp3() * self.getLenp3()) - self.getLenp1() * self.getLenp1()) / (2* self.getLenp2() * self.getLenp3()))
        return ret

    #
    def getAp2(self):
        ret =math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp3() * self.getLenp3()) - self.getLenp2() * self.getLenp2()) / (2* self.getLenp1() * self.getLenp3()))
        return ret

    def getAp3(self):
        ret = math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp2() * self.getLenp2()) - self.getLenp3() * self.getLenp3()) / (2* self.getLenp1() * self.getLenp2()))
        return ret

    def drawMe(self, g):
        self.g = g
        r = 5
        # 繪出三個頂點
        self.p1.drawMe(self.g,r)
        self.p2.drawMe(self.g,r)
        self.p3.drawMe(self.g,r)
        line1 = Line(self.p1,self.p2)
        line2 = Line(self.p1,self.p3)
        line3 = Line(self.p2,self.p3)
        # 繪出三邊線
        line1.drawMe(self.g)
        line2.drawMe(self.g)
        line3.drawMe(self.g)

    # ends Triangle def
    # 透過三個邊長定義三角形
    def setSSS(self, lenp3, lenp1, lenp2):
        self.lenp3 = lenmidpt = Point(0, 0)
        self.lenp1 = lenp1
        self.lenp2 = lenp2
        self.ap1 = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2* self.lenp2 * self.lenp3))
        self.ap2 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2* self.lenp1 * self.lenp3))
        self.ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2* self.lenp1 * self.lenp2))

    # 透過兩個邊長與夾角定義三角形
    def setSAS(self, lenp3, ap2, lenp1):
        self.lenp3 = lenp3
        self.ap2 = ap2
        self.lenp1 = lenp1
        self.lenp2 = math.sqrt((self.lenp3 * self.lenp3 + self.lenp1 * self.lenp1) - 2* self.lenp3 * self.lenp1 * math.cos(self.ap2))
        #等於 SSS(AB, BC, CA)

    def setSaSS(self, lenp2, lenp3, lenp1):
        self.lenp2 = lenp2
        self.lenp3 = lenp3
        self.lenp1 = lenp1
        if(self.lenp1 &gt; (self.lenp2 + self.lenp3)):
        #&lt;CAB 夾角為 180 度, 三點共線且 A 介於 BC 之間
            ret = math.pi
        else :
            # &lt;CAB 夾角為 0, 三點共線且 A 不在 BC 之間
            if((self.lenp1 &lt; (self.lenp2 - self.lenp3)) or (self.lenp1 &lt; (self.lenp3 - self.lenp2))):
                ret = 0.0
            else :
            # 透過餘絃定理求出夾角 &lt;CAB 
                ret = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2 * self.lenp2 * self.lenp3))
        return ret

    # 取得三角形的三個邊長值
    def getSSS(self):
        temp = []
        temp.append( self.getLenp1() )
        temp.append( self.getLenp2() )
        temp.append( self.getLenp3() )
        return temp

    # 取得三角形的三個角度值
    def getAAA(self):
        temp = []
        temp.append( self.getAp1() )
        temp.append( self.getAp2() )
        temp.append( self.getAp3() )
        return temp

    # 取得三角形的三個角度與三個邊長
    def getASASAS(self):
        temp = []
        temp.append(self.getAp1())
        temp.append(self.getLenp1())
        temp.append(self.getAp2())
        temp.append(self.getLenp2())
        temp.append(self.getAp3())
        temp.append(self.getLenp3())
        return temp
    #2P 2L return mid P
    def setPPSS(self, p1, p3, lenp1, lenp3):
        temp = []
        self.p1 = p1
        self.p3 = p3
        self.lenp1 = lenp1
        self.lenp3 = lenp3

        #bp3 is the angle beside p3 point, cp3 is the angle for line23, p2 is the output
        line31 = Line(p3, p1)
        self.lenp2 = line31.getR()
        #self.lenp2 = self.p3.distance(self.p1)
        #這裡是求角3
        ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2 * self.lenp1 * self.lenp2))
        #ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2 * self.lenp1 * self.lenp3))
        bp3 = line31.getT()
        cp3 = bp3 - ap3
        temp.append(p3.x + self.lenp1*math.cos(cp3))#p2.x
        temp.append(p3.y + self.lenp1*math.sin(cp3))#p2.y
        return temp

def tag(g, p):
    None

midpt = Point(0, 0)
tippt = Point(0, 0)
contour = []
# 執行繪圖流程, 注意 x, y 為 global variables
def draw():
    global theta, midpt, oldpt
    context.clearRect(0, 0, canvas.width, canvas.height)
    line1.drawMe(context)
    line2.drawMe(context)
    line3.drawMe(context)
    #triangle1.drawMe(context)
    #triangle2.drawMe(context)
    theta += dx
    p2.x = p1.x + line1.length*math.cos(theta*degree)
    p2.y = p1.y - line1.length*math.sin(theta*degree)
    p3.x, p3.y = triangle2.setPPSS(p2,p4,link2_len,link3_len)
    # 計算垂直單位向量
    a = Coord(p3.x, p3.y)
    b = Coord(p2.x, p2.y)
    normal = perpendicular(normalize(a-b))
    midpt.x = (p2.x + p3.x)/2
    midpt.y = (p2.y + p3.y)/2
    tippt.x = midpt.x + 150*normal.x
    tippt.y = midpt.y + 150*normal.y
    if theta &lt; 360:
        contour.append((tippt.x, tippt.y))
    context.beginPath()
    context.moveTo(midpt.x, midpt.y)
    context.lineTo(tippt.x, tippt.y)
    # 利用 fillRect 繪製一個長寬各 1 單位的正方形
    for i in range(len(contour)):
        context.fillRect(contour[i][0], contour[i][1], 1, 1)
    context.stroke()
    #p1.tag(context)


# 以上為相關函式物件的定義區
# 全域變數
# 幾何位置輸入變數
x=10
y=10
r=10

# 畫布與繪圖內容
# 其他輸入變數
theta = 0
degree = math.pi/180.0
dx = 2
dy = 4

#set p1.p2.p3.p4 position
lift = 10
p1 =  Point(150,100+lift)
p2 =  Point(150,200+lift)
p3 =  Point(300,300+lift)
p4 =  Point(350,100+lift)

#accord position create link
line1 =  Link(p1,p2)
line2 =  Link(p2,p3)
line3 =  Link(p3,p4)
line4 =  Link(p1,p4)
line5 =  Link(p2,p4)

link2_len = p2.distance(p3)
link3_len = p3.distance(p4)

#link2_len = line1.getR()
#link3_len = line3.getR()
#alert(str(link2_len)+','+str(link3_len))

triangle1 =  Triangle(p1,p2,p4)
triangle2 =  Triangle(p2,p3,p4)

# 視窗載入時執行內容
# 繪圖畫布設定

canvas = document["plotarea"]
context = canvas.getContext("2d")

# 座標轉換, 移動 canvas.height 並且 y 座標變號, 也就是將原點座標移到畫面左下角
context.translate(0,canvas.height)
context.scale(1,-1)

#以間隔 20 micro seconds 重複呼叫 draw()
timer.set_interval(draw,20)
#timer.set_interval(draw,10)
&lt;/script&gt;</pre>
<p>寫成 plt.py 模組:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import math

class Coord(object):
    def __init__(self,x,y):
        self.x = x
        self.y = y

    def __sub__(self,other):
        # This allows you to substract vectors
        return Coord(self.x-other.x,self.y-other.y)

    def __repr__(self):
        # Used to get human readable coordinates when printing
        return "Coord(%f,%f)"%(self.x,self.y)

    def length(self):
        # Returns the length of the vector
        return math.sqrt(self.x**2 + self.y**2)

    def angle(self):
        # Returns the vector's angle
        return math.atan2(self.y,self.x)

def normalize(coord):
    return Coord(
        coord.x/coord.length(),
        coord.y/coord.length()
        )

def perpendicular(coord):
    # Shifts the angle by pi/2 and calculate the coordinates
    # using the original vector length
    return Coord(
        coord.length()*math.cos(coord.angle()+math.pi/2),
        coord.length()*math.sin(coord.angle()+math.pi/2)
        )

# 點類別
class Point(object):
    # 起始方法
    def __init__(self, x, y):
        self.x = x
        self.y = y

    # 繪製方法
    def drawMe(self, g, r):
        self.g = g
        self.r = r
        self.g.save()
        self.g.moveTo(self.x,self.y)
        self.g.beginPath()
        # 根據 r 半徑繪製一個圓代表點的所在位置
        self.g.arc(self.x, self.y, self.r, 0, 2*math.pi, True)
        self.g.moveTo(self.x,self.y)
        self.g.lineTo(self.x+self.r, self.y)
        self.g.moveTo(self.x, self.y)
        self.g.lineTo(self.x-self.r, self.y)
        self.g.moveTo(self.x, self.y)
        self.g.lineTo(self.x, self.y+self.r)
        self.g.moveTo(self.x, self.y)
        self.g.lineTo(self.x, self.y-self.r)
        self.g.restore()
        self.g.stroke()

    # 加入 Eq 方法
    def Eq(self, pt):
        self.x = pt.x
        self.y = pt.y

    # 加入 setPoint 方法
    def setPoint(self, px, py):
        self.x = px
        self.y = py

    # 加上 distance(pt) 方法, 計算點到 pt 的距離
    def distance(self, pt):
        self.pt = pt
        x = self.x - self.pt.x
        y = self.y - self.pt.y
        return math.sqrt(x * x + y * y)

    # 利用文字標示點的座標位置
    def tag(self, g):
        self.g = g
        self.g.beginPath()
        self.g.fillText("%d, %d"%(self.x, self.y),self.x, self.y)
        self.g.stroke()


# Line 類別物件
class Line(object):

    # 起始方法
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        # 直線的第一點, 設為線尾
        self.Tail = self.p1
        # 直線組成的第二點, 設為線頭
        self.Head = self.p2
        # 直線的長度屬性
        self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))

    # setPP 以指定頭尾座標點來定義直線
    def setPP(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        self.Tail = self.p1
        self.Head = self.p2
        self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))

    # setRT 方法 for Line, 應該已經確定 Tail 點, 然後以 r, t 作為設定 Head 的參考
    def setRT(self, r, t):
        self.r = r
        self.t = t
        x = self.r * math.cos(self.t)
        y = self.r * math.sin(self.t)
        self.Tail.Eq(self.p1)
        self.Head.setPoint(self.Tail.x + x,self.Tail.y + y)

    # getR 方法 for Line
    def getR(self):
        # x 分量與 y 分量
        x = self.p1.x - self.p2.x
        y = self.p1.y - self.p2.y
        return math.sqrt(x * x + y * y)

    # 根據定義 atan2(y,x), 表示 (x,y) 與 正 x 軸之間的夾角, 介於 pi 與 -pi 間
    def getT(self):
        x = self.p2.x - self.p1.x
        y = self.p2.y - self.p1.y
        if (math.fabs(x) &lt; math.pow(10,-100)):
            if(y &lt; 0.0):
                return (-math.pi/2)
            else:
                return (math.pi/2)
        else:
            return math.atan2(y, x)

    # setTail 方法 for Line
    def setTail(self, pt):
        self.pt = pt
        self.Tail.Eq(pt)
        self.Head.setPoint(self.pt.x + self.x, self.pt.y + self.y)

    # getHead 方法 for Line
    def getHead(self):
        return self.Head

    def getTail(self):
        return self.Tail

    def drawMe(self, g):
        self.g = g
        self.g.beginPath()
        self.g.moveTo(self.p1.x,self.p1.y)
        self.g.lineTo(self.p2.x,self.p2.y)
        self.g.stroke()

    def test(self):
        return ("this is pure test to Inherit")


class Link(Line):
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        self.length = math.sqrt(math.pow((self.p2.x - self.p1.x), 2) + math.pow((self.p2.y - self.p1.y), 2))

    #g context
    def drawMe(self, g):
        self.g = g
        hole = 5
        radius = 10
        length = self.getR()
        # alert(length)
        # 儲存先前的繪圖狀態
        self.g.save()
        self.g.translate(self.p1.x,self.p1.y)
        #alert(str(self.p1.x)+","+str(self.p1.y))
        #self.g.rotate(-((math.pi/2)-self.getT()))
        self.g.rotate(-math.pi*0.5 + self.getT())
        #alert(str(self.getT()))
        #self.g.rotate(10*math.pi/180)
        #this.g.rotate(-(Math.PI/2-this.getT()));
        # 必須配合畫在 y 軸上的 Link, 進行座標轉換, 也可以改為畫在 x 軸上...
        self.g.beginPath()
        self.g.moveTo(0,0)
        self.g.arc(0, 0, hole, 0, 2*math.pi, True)
        self.g.stroke()
        self.g.moveTo(0,length)
        self.g.beginPath()
        self.g.arc(0,length, hole, 0, 2*math.pi, True)
        self.g.stroke()
        self.g.moveTo(0,0)
        self.g.beginPath()
        self.g.arc(0,0, radius, 0, math.pi, True)
        self.g.moveTo(0+radius,0)
        self.g.lineTo(0+radius,0+length)
        self.g.stroke()
        self.g.moveTo(0,0+length)
        self.g.beginPath()
        self.g.arc(0, 0+length, radius, math.pi, 0, True)
        self.g.moveTo(0-radius,0+length)
        self.g.lineTo(0-radius,0)
        self.g.stroke()
        self.g.restore()
        '''
        self.g.beginPath()
        self.g.fillStyle = "red"
        self.g.font = "bold 18px sans-serif"
        self.g.fillText("%d, %d"%(self.p2.x, self.p2.y),self.p2.x, self.p2.y)
        self.g.stroke()
        '''


class Triangle(object):
    def __init__(self, p1, p2, p3):
        self.p1 = p1
        self.p2 = p2
        self.p3 = p3

    def getLenp3(self):
        p1 = self.p1
        ret = p1.distance(self.p2)
        return ret

    def getLenp1(self):
        p2 = self.p2
        ret = p2.distance(self.p3)
        return ret

    def getLenp2(self):
        p1 = self.p1
        ret = p1.distance(self.p3)
        return ret

    # 角度
    def getAp1(self):
        ret = math.acos(((self.getLenp2() * self.getLenp2() + self.getLenp3() * self.getLenp3()) - self.getLenp1() * self.getLenp1()) / (2* self.getLenp2() * self.getLenp3()))
        return ret

    #
    def getAp2(self):
        ret =math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp3() * self.getLenp3()) - self.getLenp2() * self.getLenp2()) / (2* self.getLenp1() * self.getLenp3()))
        return ret

    def getAp3(self):
        ret = math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp2() * self.getLenp2()) - self.getLenp3() * self.getLenp3()) / (2* self.getLenp1() * self.getLenp2()))
        return ret

    def drawMe(self, g):
        self.g = g
        r = 5
        # 繪出三個頂點
        self.p1.drawMe(self.g,r)
        self.p2.drawMe(self.g,r)
        self.p3.drawMe(self.g,r)
        line1 = Line(self.p1,self.p2)
        line2 = Line(self.p1,self.p3)
        line3 = Line(self.p2,self.p3)
        # 繪出三邊線
        line1.drawMe(self.g)
        line2.drawMe(self.g)
        line3.drawMe(self.g)

    # ends Triangle def
    # 透過三個邊長定義三角形
    def setSSS(self, lenp3, lenp1, lenp2):
        self.lenp3 = lenp3
        self.lenp1 = lenp1
        self.lenp2 = lenp2
        self.ap1 = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2* self.lenp2 * self.lenp3))
        self.ap2 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2* self.lenp1 * self.lenp3))
        self.ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2* self.lenp1 * self.lenp2))

    # 透過兩個邊長與夾角定義三角形
    def setSAS(self, lenp3, ap2, lenp1):
        self.lenp3 = lenp3
        self.ap2 = ap2
        self.lenp1 = lenp1
        self.lenp2 = math.sqrt((self.lenp3 * self.lenp3 + self.lenp1 * self.lenp1) - 2* self.lenp3 * self.lenp1 * math.cos(self.ap2))
        #等於 SSS(AB, BC, CA)

    def setSaSS(self, lenp2, lenp3, lenp1):
        self.lenp2 = lenp2
        self.lenp3 = lenp3
        self.lenp1 = lenp1
        if(self.lenp1 &gt; (self.lenp2 + self.lenp3)):
        #&lt;CAB 夾角為 180 度, 三點共線且 A 介於 BC 之間
            ret = math.pi
        else :
            # &lt;CAB 夾角為 0, 三點共線且 A 不在 BC 之間
            if((self.lenp1 &lt; (self.lenp2 - self.lenp3)) or (self.lenp1 &lt; (self.lenp3 - self.lenp2))):
                ret = 0.0
            else :
            # 透過餘絃定理求出夾角 &lt;CAB 
                ret = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2 * self.lenp2 * self.lenp3))
        return ret

    # 取得三角形的三個邊長值
    def getSSS(self):
        temp = []
        temp.append( self.getLenp1() )
        temp.append( self.getLenp2() )
        temp.append( self.getLenp3() )
        return temp

    # 取得三角形的三個角度值
    def getAAA(self):
        temp = []
        temp.append( self.getAp1() )
        temp.append( self.getAp2() )
        temp.append( self.getAp3() )
        return temp

    # 取得三角形的三個角度與三個邊長
    def getASASAS(self):
        temp = []
        temp.append(self.getAp1())
        temp.append(self.getLenp1())
        temp.append(self.getAp2())
        temp.append(self.getLenp2())
        temp.append(self.getAp3())
        temp.append(self.getLenp3())
        return temp
    #2P 2L return mid P
    def setPPSS(self, p1, p3, lenp1, lenp3):
        temp = []
        self.p1 = p1
        self.p3 = p3
        self.lenp1 = lenp1
        self.lenp3 = lenp3

        #bp3 is the angle beside p3 point, cp3 is the angle for line23, p2 is the output
        line31 = Line(p3, p1)
        self.lenp2 = line31.getR()
        #self.lenp2 = self.p3.distance(self.p1)
        #這裡是求角3
        ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2 * self.lenp1 * self.lenp2))
        #ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2 * self.lenp1 * self.lenp3))
        bp3 = line31.getT()
        cp3 = bp3 - ap3
        temp.append(p3.x + self.lenp1*math.cos(cp3))#p2.x
        temp.append(p3.y + self.lenp1*math.sin(cp3))#p2.y
        return temp</pre>
<p>導入上述 plt.py 後執行平面四連桿運動模擬:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&lt;p&gt;將四連桿模擬程式庫存在 ./../data/py 子目錄, 然後以 import 導入方式執行運算:&lt;/p&gt;
&lt;canvas id="plotarea2" width="600" height="450"&gt;&lt;/canvas&gt;

&lt;script type="text/python3"&gt;
# import point-line-triangle module
import plt
import math
from browser import document
from browser import timer

midpt = plt.Point(0, 0)
tippt = plt.Point(0, 0)
contour = []
# 執行繪圖流程, 注意 x, y 為 global variables
def draw():
    global theta, midpt, oldpt
    context.clearRect(0, 0, canvas.width, canvas.height)
    line1.drawMe(context)
    line2.drawMe(context)
    line3.drawMe(context)
    line4.drawMe(context)
    #triangle1.drawMe(context)
    #triangle2.drawMe(context)
    theta += dx
    #PLAP
    p2.x = p1.x + line1.length*math.cos(theta*degree)
    p2.y = p1.y - line1.length*math.sin(theta*degree)
    #PLLP
    p3.x, p3.y = triangle2.setPPSS(p2,p4,line2.length,line3.length)
    # 計算垂直單位向量
    a = plt.Coord(p3.x, p3.y)
    b = plt.Coord(p2.x, p2.y)
    normal = plt.perpendicular(plt.normalize(a-b))
    midpt.x = (p2.x + p3.x)/2
    midpt.y = (p2.y + p3.y)/2
    tippt.x = midpt.x + 150*normal.x
    tippt.y = midpt.y + 150*normal.y
    if theta &lt; 360:
        contour.append((tippt.x, tippt.y))
    context.beginPath()
    context.moveTo(midpt.x, midpt.y)
    context.lineTo(tippt.x, tippt.y)
    # 利用 fillRect 繪製一個長寬各 1 單位的正方形
    for i in range(len(contour)):
        context.fillRect(contour[i][0], contour[i][1], 1, 1)
    context.stroke()
    #p1.tag(context)


# 以上為相關函式物件的定義區
# 全域變數
# 幾何位置輸入變數
x=10
y=10
r=10

# 畫布與繪圖內容
# 其他輸入變數
theta = 0
degree = math.pi/180.0
dx = 2
dy = 4

#set p1.p2.p3.p4 position
lift = 10
# 各起始座標點必須精確
p1 =  plt.Point(150,100+lift)
p2 =  plt.Point(150,200+lift)
p3 =  plt.Point(300,300+lift)
p4 =  plt.Point(350,100+lift)
#共有五條線
line1 =  plt.Link(p1,p2)
line2 =  plt.Link(p2,p3)
line3 =  plt.Link(p3,p4)
line4 =  plt.Link(p1,p4)
line5 =  plt.Link(p2,p4)

#link2_len = p2.distance(p3)
#link3_len = p3.distance(p4)

#link2_len = line1.getR()
#link3_len = line3.getR()
#alert(str(link2_len)+','+str(link3_len))

triangle1 =  plt.Triangle(p1,p2,p4)
triangle2 =  plt.Triangle(p2,p3,p4)

# 視窗載入時執行內容
# 繪圖畫布設定

canvas = document["plotarea2"]
context = canvas.getContext("2d")

# 座標轉換, 移動 canvas.height 並且 y 座標變號, 也就是將原點座標移到畫面左下角
context.translate(0,canvas.height)
context.scale(1,-1)

#以間隔 20 micro seconds 重複呼叫 draw()
timer.set_interval(draw,20)
&lt;/script&gt;</pre>
<p></p>